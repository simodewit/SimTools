<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nefarius.Utilities.DeviceManagement</name>
    </assembly>
    <members>
        <member name="T:Nefarius.Utilities.DeviceManagement.Drivers.DriverMeta">
            <summary>
                Driver meta data fetched from the registry.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Drivers.DriverMeta.DriverDate">
            <summary>
                Gets the date of the driver.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Drivers.DriverMeta.DriverDescription">
            <summary>
                Gets the description the device got from the function driver.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Drivers.DriverMeta.DriverVersion">
            <summary>
                Gets the driver version.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Drivers.DriverMeta.InfPath">
            <summary>
                Gets the active INF name/sub-path. Typically resides in C:\Windows\INF.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Drivers.DriverMeta.InfSection">
            <summary>
                Gets the section of the INF which applied on driver installation.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Drivers.DriverMeta.MatchingDeviceId">
            <summary>
                Gets the device ID this driver is active on.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Drivers.DriverMeta.ProviderName">
            <summary>
                Gets the provider (manufacturer) name of the driver.
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Drivers.DriverStore">
            <summary>
                Driver Store enumeration and manipulation utility.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Drivers.DriverStore.ExistingDrivers">
            <summary>
                Gets a list of existing packages (absolute INF paths) in the local driver store.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Drivers.DriverStore.RemoveDriver(System.String)">
            <summary>
                Removes a driver identified by absolute package path.
            </summary>
            <param name="driverStoreFileName">The absolute package path to remove.</param>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Drivers.FilterDrivers">
            <summary>
                Utility class to simplify interaction with filter driver entries.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Drivers.FilterDrivers.GetDeviceClassUpperFilters(System.Guid)">
            <summary>
                Gets the upper filter service names (if any) for a provided class GUID.
            </summary>
            <param name="classGuid">The device class GUID.</param>
            <returns>A list of filter service names.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Drivers.FilterDrivers.GetDeviceClassLowerFilters(System.Guid)">
            <summary>
                Gets the lower filter service names (if any) for a provided class GUID.
            </summary>
            <param name="classGuid">The device class GUID.</param>
            <returns>A list of filter service names.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Drivers.FilterDrivers.RemoveDeviceClassUpperFilter(System.Guid,System.String)">
            <summary>
                Removes a driver service from the upper filters of a provided class GUID.
            </summary>
            <param name="classGuid">The device class GUID.</param>
            <param name="serviceName">The driver service name to remove.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Drivers.FilterDrivers.RemoveDeviceClassLowerFilter(System.Guid,System.String)">
            <summary>
                Removes a driver service from the lower filters of a provided class GUID.
            </summary>
            <param name="classGuid">The device class GUID.</param>
            <param name="serviceName">The driver service name to remove.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Drivers.FilterDrivers.AddDeviceClassUpperFilter(System.Guid,System.String)">
            <summary>
                Adds a driver service to the upper filters of a provided class GUID.
            </summary>
            <param name="classGuid">The device class GUID.</param>
            <param name="serviceName">The driver service name to add.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Drivers.FilterDrivers.AddDeviceClassLowerFilter(System.Guid,System.String)">
            <summary>
                Adds a driver service to the lower filters of a provided class GUID.
            </summary>
            <param name="classGuid">The device class GUID.</param>
            <param name="serviceName">The driver service name to add.</param>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException">
            <summary>
                A Configuration Manager API has failed.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException.Message">
            <inheritdoc />
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException.Value">
            <summary>
                The CONFIGRET value of the error.
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Exceptions.DriverServiceNotFoundException">
            <summary>
                A driver service wasn't found on the local machine.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Exceptions.DriverServiceNotFoundException.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Exceptions.PnPDeviceNotFoundException">
            <summary>
                The desired device instance was not found on the system.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Exceptions.PnPDeviceNotFoundException.InstanceId">
            <summary>
                The instance ID of the device queried for.
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Exceptions.UsbPnPDeviceException">
            <summary>
                A <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.UsbPnPDevice" /> related exception.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Exceptions.UsbPnPDeviceException.#ctor(System.String)">
            <summary>
                A <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.UsbPnPDevice" /> operation has failed.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Exceptions.UsbPnPDeviceConversionException">
            <summary>
                Thrown if a conversion of a <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" /> to a <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.UsbPnPDevice" /> wasn't possible.
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Exceptions.UsbPnPDeviceRestartException">
            <summary>
                Thrown if a port-cycle operation of a <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.UsbPnPDevice" /> failed.
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception">
            <summary>
                A Win32 API has failed.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception.#ctor(System.String)">
            <summary>
                A Win32 API has failed.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception.#ctor(System.String,System.Int32)">
            <summary>
                A Win32 API has failed.
            </summary>
            <param name="message">The error message.</param>
            <param name="errorCode">The error code.</param>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception.ErrorCode">
            <summary>
                The native Windows error code.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception.ErrorMessage">
            <summary>
                The Win32 error message.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception.GetMessageFor(System.Nullable{System.Int32})">
            <summary>
                Translates a Win32 error code to the user-readable message.
            </summary>
            <param name="errorCode">The Win32 error code. Gets fetched from <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> if null.</param>
            <returns>The message, if any, or null.</returns>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Extensions.PnPDeviceExtensions">
            <summary>
                Helper methods for <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" /> objects.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Extensions.PnPDeviceExtensions.ToUsbPnPDevice(Nefarius.Utilities.DeviceManagement.PnP.PnPDevice)">
            <summary>
                Creates a <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.UsbPnPDevice" /> from the provided <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" />.
            </summary>
            <param name="device">The <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" /> to base this USB device on.</param>
            <returns>The new <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.UsbPnPDevice" />.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Extensions.PnPDeviceExtensions.GetCurrentDriver(Nefarius.Utilities.DeviceManagement.PnP.PnPDevice)">
            <summary>
                Fetches meta data about the currently active driver of the <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" />.
            </summary>
            <param name="device">The <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" /> to fetch driver info for.</param>
            <returns>The <see cref="T:Nefarius.Utilities.DeviceManagement.Drivers.DriverMeta" /> instance.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if registry access failed.</exception>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.Devcon">
            <summary>
                "Device Console" utility class. Managed wrapper for common SetupAPI actions.
            </summary>
            <remarks>https://docs.microsoft.com/en-us/windows-hardware/drivers/install/setupapi</remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.FindInDeviceClassByHardwareId(System.Guid,System.String)">
            <summary>
                Attempts to find a device within a specified device class by a given hardware ID.
            </summary>
            <param name="target">The device class GUID.</param>
            <param name="hardwareId">The hardware ID to search for.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.FindInDeviceClassByHardwareId(System.Guid,System.String,System.Collections.Generic.IEnumerable{System.String}@)">
            <summary>
                Attempts to find a device within a specified device class by a given hardware ID.
            </summary>
            <param name="target">The device class GUID.</param>
            <param name="hardwareId">The hardware ID to search for.</param>
            <param name="instanceIds">A list of instances found for the given search criteria.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.FindInDeviceClassByHardwareId(System.Guid,System.String,System.Collections.Generic.IEnumerable{System.String}@,System.Boolean,System.Boolean)">
            <summary>
                Attempts to find a device within a specified device class by a given hardware ID.
            </summary>
            <param name="target">The device class GUID.</param>
            <param name="hardwareId">The hardware ID to search for.</param>
            <param name="instanceIds">A list of instances found for the given search criteria.</param>
            <param name="presentOnly">True to filter currently plugged in devices, false to get all matching devices.</param>
            <param name="allowPartial">True to match substrings, false to match the exact ID value.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.FindByInterfaceGuid(System.Guid,System.String@,System.String@,System.Int32,System.Boolean)">
            <summary>
                Searches for devices matching the provided interface GUID and returns the device path and instance ID.
            </summary>
            <param name="target">The interface GUID to enumerate.</param>
            <param name="path">The device path of the enumerated device.</param>
            <param name="instanceId">The instance ID of the enumerated device.</param>
            <param name="instance">Optional instance ID (zero-based) specifying the device to process on multiple matches.</param>
            <param name="presentOnly">
                Only enumerate currently connected devices by default, set to False to also include phantom
                devices.
            </param>
            <returns>True if at least one device was found with the provided class, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.FindByInterfaceGuid(System.Guid,Nefarius.Utilities.DeviceManagement.PnP.PnPDevice@,System.Int32,System.Boolean)">
            <summary>
                Searches for devices matching the provided interface GUID and returns a <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" />.
            </summary>
            <param name="target">The interface GUID to enumerate.</param>
            <param name="device">The <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" /> wrapper object.</param>
            <param name="instance">Optional instance ID (zero-based) specifying the device to process on multiple matches.</param>
            <param name="presentOnly">
                Only enumerate currently connected devices by default, set to False to also include phantom
                devices.
            </param>
            <returns>True if at least one device was found with the provided class, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Find(System.Guid,System.String@,System.String@,System.Int32)">
            <summary>
                Searches for devices matching the provided interface GUID and returns the device path and instance ID.
            </summary>
            <param name="target">The class GUID to enumerate.</param>
            <param name="path">The device path of the enumerated device.</param>
            <param name="instanceId">The instance ID of the enumerated device.</param>
            <param name="instance">Optional instance ID (zero-based) specifying the device to process on multiple matches.</param>
            <returns>True if at least one device was found with the provided class, false otherwise.</returns>
            <remarks>
                This is here for backwards compatibility, please use
                <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.FindByInterfaceGuid(System.Guid,System.String@,System.String@,System.Int32,System.Boolean)" /> instead.
            </remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Install(System.String,System.Boolean@)">
            <summary>
                Invokes the installation of a driver via provided .INF file.
            </summary>
            <param name="fullInfPath">An absolute path to the .INF file to install.</param>
            <param name="rebootRequired">True if a machine reboot is required, false otherwise.</param>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Create(System.String,System.Guid,System.String)">
            <summary>
                Creates a virtual device node (hardware ID) in the provided device class.
            </summary>
            <param name="className">The device class name.</param>
            <param name="classGuid">The GUID of the device class.</param>
            <param name="node">The node path terminated by two null characters.</param>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Remove(System.Guid,System.String)">
            <summary>
                Removed a device node identified by class GUID, path and instance ID.
            </summary>
            <param name="classGuid">The device class GUID.</param>
            <param name="instanceId">The instance ID.</param>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Remove(System.Guid,System.String,System.Boolean@)">
            <summary>
                Removed a device node identified by interface GUID and instance ID.
            </summary>
            <param name="classGuid">The device class GUID.</param>
            <param name="instanceId">The instance ID.</param>
            <param name="rebootRequired">True if a reboot is required to complete the uninstall action, false otherwise.</param>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Refresh">
            <summary>
                Instructs the system to re-enumerate hardware devices.
            </summary>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.RefreshPhantom">
            <summary>
                Instructs the system to re-enumerate hardware devices including disconnected ones.
            </summary>
            <returns>True on success, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Update(System.String,System.String,System.Boolean@)">
            <summary>
                Given an INF file and a hardware ID, this function installs updated drivers for devices that match the hardware ID.
            </summary>
            <param name="hardwareId">A string that supplies the hardware identifier to match existing devices on the computer.</param>
            <param name="fullInfPath">A string that supplies the full path file name of an INF file.</param>
            <param name="rebootRequired">A variable that indicates whether a restart is required and who should prompt for it.</param>
            <returns>
                The function returns TRUE if a device was upgraded to the specified driver.
                Otherwise, it returns FALSE and the logged error can be retrieved with a call to GetLastError.
            </returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.DeleteDriver(System.String,System.String,System.Boolean)">
            <summary>
                Uninstalls a driver identified via a given INF and optionally removes it from the driver store as well.
            </summary>
            <param name="oemInfName">The OEM INF name (name and extension only).</param>
            <param name="fullInfPath">The fully qualified absolute path to the INF to remove from driver store.</param>
            <param name="forceDelete">Remove driver store copy, if true.</param>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassFilters">
            <summary>
                Utility class to adjust class filter settings.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassFilters.AddUpper(System.Guid,System.String)">
            <summary>
                Adds an entry to the device class upper filters.
            </summary>
            <param name="classGuid">The device class GUID to modify.</param>
            <param name="service">The driver service name to add.</param>
            <remarks>
                If the filters value doesn't exist, it will get created. If the provided service entry already exists, it will not
                get added again. Throws a <see cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.DriverServiceNotFoundException" /> if the provided service doesn't exist.
            </remarks>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception" />
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.DriverServiceNotFoundException" />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassFilters.RemoveUpper(System.Guid,System.String)">
            <summary>
                Removes an entry from the device class upper filters.
            </summary>
            <param name="classGuid">The device class GUID to modify.</param>
            <param name="service">The driver service name to add.</param>
            <remarks>
                If the provided service entry doesn't exist or the entire filter value is not present, this method does
                nothing.
            </remarks>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception" />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassFilters.GetUpper(System.Guid)">
            <summary>
                Returns the list of device class upper filter services configured, or null of the value doesn't exist at all.
            </summary>
            <param name="classGuid">The device class GUID to query.</param>
            <returns>A list of service names or null.</returns>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception" />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassFilters.DeleteUpper(System.Guid)">
            <summary>
                Deletes the entire upper filters value for the provided device class.
            </summary>
            <param name="classGuid">The device class GUID to delete the value for.</param>
            <remarks>If the value doesn't exist, this method does nothing.</remarks>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception" />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassFilters.AddLower(System.Guid,System.String)">
            <summary>
                Adds an entry to the device class lower filters.
            </summary>
            <param name="classGuid">The device class GUID to modify.</param>
            <param name="service">The driver service name to add.</param>
            <remarks>
                If the filters value doesn't exist, it will get created. If the provided service entry already exists, it will not
                get added again. Throws a <see cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.DriverServiceNotFoundException" /> if the provided service doesn't exist.
            </remarks>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception" />
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.DriverServiceNotFoundException" />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassFilters.RemoveLower(System.Guid,System.String)">
            <summary>
                Removes an entry from the device class lower filters.
            </summary>
            <param name="classGuid">The device class GUID to modify.</param>
            <param name="service">The driver service name to add.</param>
            <remarks>
                If the provided service entry doesn't exist or the entire filter value is not present, this method does
                nothing.
            </remarks>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception" />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassFilters.GetLower(System.Guid)">
            <summary>
                Returns the list of device class lower filter services configured, or null of the value doesn't exist at all.
            </summary>
            <param name="classGuid">The device class GUID to query.</param>
            <returns>A list of service names or null.</returns>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception" />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassFilters.DeleteLower(System.Guid)">
            <summary>
                Deletes the entire lower filters value for the provided device class.
            </summary>
            <param name="classGuid">The device class GUID to delete the value for.</param>
            <remarks>If the value doesn't exist, this method does nothing.</remarks>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception" />
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassIds">
            <summary>
                Provides common device class <see cref="T:System.Guid" />s.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassIds.System">
            <summary>
                System devices.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassIds.Usb">
            <summary>
                USB devices.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassIds.Bluetooth">
            <summary>
                Bluetooth devices.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassIds.XnaComposite">
            <summary>
                Xbox 360 Peripherals.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassIds.XboxComposite">
            <summary>
                Xbox Peripherals.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceClassIds.HumanInterfaceDevices">
            <summary>
                Human Interface Devices (HID).
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs">
            <summary>
                Device change event arguments.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs.InterfaceGuid">
            <summary>
                The <see cref="T:System.Guid" /> of the device interface.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs.SymLink">
            <summary>
                The symbolic link path.
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceInterfaceIds">
            <summary>
                Provides common device interface <see cref="T:System.Guid" />s.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceInterfaceIds.UsbHostController">
            <summary>
                An interface exposed on USB host controllers.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceInterfaceIds.UsbHub">
            <summary>
                An interface exposed on USB hubs.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceInterfaceIds.UsbDevice">
            <summary>
                An interface exposed on USB devices.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceInterfaceIds.XUsbDevice">
            <summary>
                An interface exposed on XUSB (Xbox 360) or XGIP (Xbox One) compatible (XInput) devices.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DeviceInterfaceIds.HidDevice">
            <summary>
                An interface exposed on HID devices.
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags">
            <summary>
                A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device
                instance identifier:
                CM_LOCATE_DEVNODE_NORMAL
                The function retrieves the device instance handle for the specified device only if the device is currently
                configured in the device tree.
                CM_LOCATE_DEVNODE_PHANTOM
                The function retrieves a device instance handle for the specified device if the device is currently configured in
                the device tree or the device is a nonpresent device that is not currently configured in the device tree.
                CM_LOCATE_DEVNODE_CANCELREMOVE
                The function retrieves a device instance handle for the specified device if the device is currently configured in
                the device tree or in the process of being removed from the device tree. If the device is in the process of being
                removed, the function cancels the removal of the device.
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags.Normal">
            <summary>
                The function retrieves the device instance handle for the specified device only if the device is currently
                configured in the device tree.
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags.Phantom">
            <summary>
                The function retrieves a device instance handle for the specified device if the device is currently configured in
                the device tree or the device is a nonpresent device that is not currently configured in the device tree.
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags.CancelRemove">
            <summary>
                The function retrieves a device instance handle for the specified device if the device is currently configured in
                the device tree or in the process of being removed from the device tree. If the device is in the process of being
                removed, the function cancels the removal of the device.
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener">
            <summary>
                Utility class to listen for system-wide device arrivals and removals based on a provided device interface GUID.
            </summary>
            <remarks>Original source: https://gist.github.com/emoacht/73eff195317e387f4cda</remarks>
        </member>
        <member name="E:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.DeviceArrived">
            <summary>
                Gets invoked when a new device has arrived (plugged in).
            </summary>
        </member>
        <member name="E:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.DeviceRemoved">
            <summary>
                Gets invoked when an existing device has been removed (unplugged).
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.RegisterDeviceArrived(System.Action{Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs},System.Nullable{System.Guid})">
            <summary>
                Subscribe a custom event handler to device arrival events.
            </summary>
            <param name="handler">The event handler to invoke.</param>
            <param name="interfaceGuid">The interface GUID to get notified for or null to get notified for all listening GUIDs.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.UnregisterDeviceArrived(System.Action{Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs})">
            <summary>
                Unsubscribe a previously registered event handler.
            </summary>
            <param name="handler">The event handler to unsubscribe.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.RegisterDeviceRemoved(System.Action{Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs},System.Nullable{System.Guid})">
            <summary>
                Subscribe a custom event handler to device removal events.
            </summary>
            <param name="handler">The event handler to invoke.</param>
            <param name="interfaceGuid">The interface GUID to get notified for or null to get notified for all listening GUIDs.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.UnregisterDeviceRemoved(System.Action{Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs})">
            <summary>
                Unsubscribe a previously registered event handler.
            </summary>
            <param name="handler">The event handler to unsubscribe.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.StartListen(System.Guid)">
            <summary>
                Start listening for device arrivals/removals using the provided <see cref="T:System.Guid" />. Call this after you've
                subscribed to <see cref="E:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.DeviceArrived" /> and <see cref="E:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.DeviceRemoved" /> events.
            </summary>
            <param name="interfaceGuid">The device interface GUID to listen for.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.StopListen(System.Nullable{System.Guid})">
            <summary>
                Stop listening. The events <see cref="E:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.DeviceArrived" /> and <see cref="E:Nefarius.Utilities.DeviceManagement.PnP.DeviceNotificationListener.DeviceRemoved" /> will not get invoked
                anymore after this call. If no <see cref="T:System.Guid" /> is specified, all currently registered interfaces will get
                unsubscribed.
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey">
            <summary>
                Describes a unified device property.
            </summary>
            <remarks>https://docs.microsoft.com/en-us/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-</remarks>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.CategoryGuid">
            <summary>
                The <see cref="T:System.Guid" /> for teh category this property belongs to.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.PropertyIdentifier">
            <summary>
                The unique identifier withing the category group for this property.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.PropertyType">
            <summary>
                The managed type of the property (integer, string, array, ...).
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Equals(Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey)">
            <inheritdoc />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.GetHashCode">
            <inheritdoc />
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.NAME">
            <summary>
                DEVPKEY_NAME
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DeviceDesc">
            <summary>
                DEVPKEY_Device_DeviceDesc
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_HardwareIds">
            <summary>
                DEVPKEY_Device_HardwareIds
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_CompatibleIds">
            <summary>
                DEVPKEY_Device_CompatibleIds
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Service">
            <summary>
                DEVPKEY_Device_Service
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Class">
            <summary>
                DEVPKEY_Device_Class
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ClassGuid">
            <summary>
                DEVPKEY_Device_ClassGuid
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Driver">
            <summary>
                DEVPKEY_Device_Driver
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ConfigFlags">
            <summary>
                DEVPKEY_Device_ConfigFlags
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Manufacturer">
            <summary>
                DEVPKEY_Device_Manufacturer
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_FriendlyName">
            <summary>
                DEVPKEY_Device_FriendlyName
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_LocationInfo">
            <summary>
                DEVPKEY_Device_LocationInfo
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_PDOName">
            <summary>
                DEVPKEY_Device_PDOName
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Capabilities">
            <summary>
                DEVPKEY_Device_Capabilities
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_UINumber">
            <summary>
                DEVPKEY_Device_UINumber
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_UpperFilters">
            <summary>
                DEVPKEY_Device_UpperFilters
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_LowerFilters">
            <summary>
                DEVPKEY_Device_LowerFilters
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_BusTypeGuid">
            <summary>
                DEVPKEY_Device_BusTypeGuid
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_LegacyBusType">
            <summary>
                DEVPKEY_Device_LegacyBusType
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_BusNumber">
            <summary>
                DEVPKEY_Device_BusNumber
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_EnumeratorName">
            <summary>
                DEVPKEY_Device_EnumeratorName
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DevType">
            <summary>
                DEVPKEY_Device_DevType
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Exclusive">
            <summary>
                DEVPKEY_Device_Exclusive
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Characteristics">
            <summary>
                DEVPKEY_Device_Characteristics
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Address">
            <summary>
                DEVPKEY_Device_Address
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_UINumberDescFormat">
            <summary>
                DEVPKEY_Device_UINumberDescFormat
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_PowerData">
            <summary>
                DEVPKEY_Device_PowerData
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_RemovalPolicy">
            <summary>
                DEVPKEY_Device_RemovalPolicy
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_RemovalPolicyDefault">
            <summary>
                DEVPKEY_Device_RemovalPolicyDefault
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_RemovalPolicyOverride">
            <summary>
                DEVPKEY_Device_RemovalPolicyOverride
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_InstallState">
            <summary>
                DEVPKEY_Device_InstallState
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_LocationPaths">
            <summary>
                DEVPKEY_Device_LocationPaths
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_BaseContainerId">
            <summary>
                DEVPKEY_Device_BaseContainerId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_InstanceId">
            <summary>
                DEVPKEY_Device_InstanceId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DevNodeStatus">
            <summary>
                DEVPKEY_Device_DevNodeStatus
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ProblemCode">
            <summary>
                DEVPKEY_Device_ProblemCode
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_EjectionRelations">
            <summary>
                DEVPKEY_Device_EjectionRelations
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_RemovalRelations">
            <summary>
                DEVPKEY_Device_RemovalRelations
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_PowerRelations">
            <summary>
                DEVPKEY_Device_PowerRelations
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_BusRelations">
            <summary>
                DEVPKEY_Device_BusRelations
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Parent">
            <summary>
                DEVPKEY_Device_Parent
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Children">
            <summary>
                DEVPKEY_Device_Children
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Siblings">
            <summary>
                DEVPKEY_Device_Siblings
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_TransportRelations">
            <summary>
                DEVPKEY_Device_TransportRelations
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ProblemStatus">
            <summary>
                DEVPKEY_Device_ProblemStatus
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Reported">
            <summary>
                DEVPKEY_Device_Reported
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Legacy">
            <summary>
                DEVPKEY_Device_Legacy
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ContainerId">
            <summary>
                DEVPKEY_Device_ContainerId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_InLocalMachineContainer">
            <summary>
                DEVPKEY_Device_InLocalMachineContainer
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Model">
            <summary>
                DEVPKEY_Device_Model
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ModelId">
            <summary>
                DEVPKEY_Device_ModelId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_FriendlyNameAttributes">
            <summary>
                DEVPKEY_Device_FriendlyNameAttributes
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ManufacturerAttributes">
            <summary>
                DEVPKEY_Device_ManufacturerAttributes
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_PresenceNotForDevice">
            <summary>
                DEVPKEY_Device_PresenceNotForDevice
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_SignalStrength">
            <summary>
                DEVPKEY_Device_SignalStrength
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_IsAssociateableByUserAction">
            <summary>
                DEVPKEY_Device_IsAssociateableByUserAction
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ShowInUninstallUI">
            <summary>
                DEVPKEY_Device_ShowInUninstallUI
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_CompanionApps">
            <summary>
                DEVPKEY_Device_CompanionApps
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_PrimaryCompanionApp">
            <summary>
                DEVPKEY_Device_PrimaryCompanionApp
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Numa_Proximity_Domain">
            <summary>
                DEVPKEY_Device_Numa_Proximity_Domain
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DHP_Rebalance_Policy">
            <summary>
                DEVPKEY_Device_DHP_Rebalance_Policy
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Numa_Node">
            <summary>
                DEVPKEY_Device_Numa_Node
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_BusReportedDeviceDesc">
            <summary>
                DEVPKEY_Device_BusReportedDeviceDesc
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_IsPresent">
            <summary>
                DEVPKEY_Device_IsPresent
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_HasProblem">
            <summary>
                DEVPKEY_Device_HasProblem
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ConfigurationId">
            <summary>
                DEVPKEY_Device_ConfigurationId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ReportedDeviceIdsHash">
            <summary>
                DEVPKEY_Device_ReportedDeviceIdsHash
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_PhysicalDeviceLocation">
            <summary>
                DEVPKEY_Device_PhysicalDeviceLocation
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_BiosDeviceName">
            <summary>
                DEVPKEY_Device_BiosDeviceName
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverProblemDesc">
            <summary>
                DEVPKEY_Device_DriverProblemDesc
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DebuggerSafe">
            <summary>
                DEVPKEY_Device_DebuggerSafe
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_PostInstallInProgress">
            <summary>
                DEVPKEY_Device_PostInstallInProgress
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_Stack">
            <summary>
                DEVPKEY_Device_Stack
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ExtendedConfigurationIds">
            <summary>
                DEVPKEY_Device_ExtendedConfigurationIds
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_IsRebootRequired">
            <summary>
                DEVPKEY_Device_IsRebootRequired
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_FirmwareDate">
            <summary>
                DEVPKEY_Device_FirmwareDate
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_FirmwareVersion">
            <summary>
                DEVPKEY_Device_FirmwareVersion
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_FirmwareRevision">
            <summary>
                DEVPKEY_Device_FirmwareRevision
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DependencyProviders">
            <summary>
                DEVPKEY_Device_DependencyProviders
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DependencyDependents">
            <summary>
                DEVPKEY_Device_DependencyDependents
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_SoftRestartSupported">
            <summary>
                DEVPKEY_Device_SoftRestartSupported
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ExtendedAddress">
            <summary>
                DEVPKEY_Device_ExtendedAddress
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_AssignedToGuest">
            <summary>
                DEVPKEY_Device_AssignedToGuest
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_CreatorProcessId">
            <summary>
                DEVPKEY_Device_CreatorProcessId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_FirmwareVendor">
            <summary>
                DEVPKEY_Device_FirmwareVendor
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_SessionId">
            <summary>
                DEVPKEY_Device_SessionId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_InstallDate">
            <summary>
                DEVPKEY_Device_InstallDate
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_FirstInstallDate">
            <summary>
                DEVPKEY_Device_FirstInstallDate
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_LastArrivalDate">
            <summary>
                DEVPKEY_Device_LastArrivalDate
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_LastRemovalDate">
            <summary>
                DEVPKEY_Device_LastRemovalDate
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverDate">
            <summary>
                DEVPKEY_Device_DriverDate
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverVersion">
            <summary>
                DEVPKEY_Device_DriverVersion
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverDesc">
            <summary>
                DEVPKEY_Device_DriverDesc
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverInfPath">
            <summary>
                DEVPKEY_Device_DriverInfPath
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverInfSection">
            <summary>
                DEVPKEY_Device_DriverInfSection
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverInfSectionExt">
            <summary>
                DEVPKEY_Device_DriverInfSectionExt
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_MatchingDeviceId">
            <summary>
                DEVPKEY_Device_MatchingDeviceId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverProvider">
            <summary>
                DEVPKEY_Device_DriverProvider
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverPropPageProvider">
            <summary>
                DEVPKEY_Device_DriverPropPageProvider
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverCoInstallers">
            <summary>
                DEVPKEY_Device_DriverCoInstallers
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ResourcePickerTags">
            <summary>
                DEVPKEY_Device_ResourcePickerTags
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_ResourcePickerExceptions">
            <summary>
                DEVPKEY_Device_ResourcePickerExceptions
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverRank">
            <summary>
                DEVPKEY_Device_DriverRank
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_DriverLogoLevel">
            <summary>
                DEVPKEY_Device_DriverLogoLevel
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_NoConnectSound">
            <summary>
                DEVPKEY_Device_NoConnectSound
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_GenericDriverInstalled">
            <summary>
                DEVPKEY_Device_GenericDriverInstalled
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_AdditionalSoftwareRequested">
            <summary>
                DEVPKEY_Device_AdditionalSoftwareRequested
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_SafeRemovalRequired">
            <summary>
                DEVPKEY_Device_SafeRemovalRequired
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.Device_SafeRemovalRequiredOverride">
            <summary>
                DEVPKEY_Device_SafeRemovalRequiredOverride
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DrvPkg_Model">
            <summary>
                DEVPKEY_DrvPkg_Model
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DrvPkg_VendorWebSite">
            <summary>
                DEVPKEY_DrvPkg_VendorWebSite
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DrvPkg_DetailedDescription">
            <summary>
                DEVPKEY_DrvPkg_DetailedDescription
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DrvPkg_DocumentationLink">
            <summary>
                DEVPKEY_DrvPkg_DocumentationLink
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DrvPkg_Icon">
            <summary>
                DEVPKEY_DrvPkg_Icon
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DrvPkg_BrandingIcon">
            <summary>
                DEVPKEY_DrvPkg_BrandingIcon
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_UpperFilters">
            <summary>
                DEVPKEY_DeviceClass_UpperFilters
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_LowerFilters">
            <summary>
                DEVPKEY_DeviceClass_LowerFilters
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_DevType">
            <summary>
                DEVPKEY_DeviceClass_DevType
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_Exclusive">
            <summary>
                DEVPKEY_DeviceClass_Exclusive
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_Characteristics">
            <summary>
                DEVPKEY_DeviceClass_Characteristics
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_Name">
            <summary>
                DEVPKEY_DeviceClass_Name
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_ClassName">
            <summary>
                DEVPKEY_DeviceClass_ClassName
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_Icon">
            <summary>
                DEVPKEY_DeviceClass_Icon
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_ClassInstaller">
            <summary>
                DEVPKEY_DeviceClass_ClassInstaller
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_PropPageProvider">
            <summary>
                DEVPKEY_DeviceClass_PropPageProvider
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_NoInstallClass">
            <summary>
                DEVPKEY_DeviceClass_NoInstallClass
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_NoDisplayClass">
            <summary>
                DEVPKEY_DeviceClass_NoDisplayClass
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_SilentInstall">
            <summary>
                DEVPKEY_DeviceClass_SilentInstall
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_NoUseClass">
            <summary>
                DEVPKEY_DeviceClass_NoUseClass
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_DefaultService">
            <summary>
                DEVPKEY_DeviceClass_DefaultService
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_IconPath">
            <summary>
                DEVPKEY_DeviceClass_IconPath
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_DHPRebalanceOptOut">
            <summary>
                DEVPKEY_DeviceClass_DHPRebalanceOptOut
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceClass_ClassCoInstallers">
            <summary>
                DEVPKEY_DeviceClass_ClassCoInstallers
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceInterface_FriendlyName">
            <summary>
                DEVPKEY_DeviceInterface_FriendlyName
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceInterface_Enabled">
            <summary>
                DEVPKEY_DeviceInterface_Enabled
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceInterface_ClassGuid">
            <summary>
                DEVPKEY_DeviceInterface_ClassGuid
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceInterface_ReferenceString">
            <summary>
                DEVPKEY_DeviceInterface_ReferenceString
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceInterface_Restricted">
            <summary>
                DEVPKEY_DeviceInterface_Restricted
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceInterface_UnrestrictedAppCapabilities">
            <summary>
                DEVPKEY_DeviceInterface_UnrestrictedAppCapabilities
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceInterface_SchematicName">
            <summary>
                DEVPKEY_DeviceInterface_SchematicName
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceInterfaceClass_DefaultInterface">
            <summary>
                DEVPKEY_DeviceInterfaceClass_DefaultInterface
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceInterfaceClass_Name">
            <summary>
                DEVPKEY_DeviceInterfaceClass_Name
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_DiscoveryMethod">
            <summary>
                DEVPKEY_DeviceContainer_DiscoveryMethod
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsEncrypted">
            <summary>
                DEVPKEY_DeviceContainer_IsEncrypted
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsAuthenticated">
            <summary>
                DEVPKEY_DeviceContainer_IsAuthenticated
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsConnected">
            <summary>
                DEVPKEY_DeviceContainer_IsConnected
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsPaired">
            <summary>
                DEVPKEY_DeviceContainer_IsPaired
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_Icon">
            <summary>
                DEVPKEY_DeviceContainer_Icon
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_Version">
            <summary>
                DEVPKEY_DeviceContainer_Version
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_Last_Seen">
            <summary>
                DEVPKEY_DeviceContainer_Last_Seen
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_Last_Connected">
            <summary>
                DEVPKEY_DeviceContainer_Last_Connected
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsShowInDisconnectedState">
            <summary>
                DEVPKEY_DeviceContainer_IsShowInDisconnectedState
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsLocalMachine">
            <summary>
                DEVPKEY_DeviceContainer_IsLocalMachine
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_MetadataPath">
            <summary>
                DEVPKEY_DeviceContainer_MetadataPath
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsMetadataSearchInProgress">
            <summary>
                DEVPKEY_DeviceContainer_IsMetadataSearchInProgress
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_MetadataChecksum">
            <summary>
                DEVPKEY_DeviceContainer_MetadataChecksum
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsNotInterestingForDisplay">
            <summary>
                DEVPKEY_DeviceContainer_IsNotInterestingForDisplay
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_LaunchDeviceStageOnDeviceConnect">
            <summary>
                DEVPKEY_DeviceContainer_LaunchDeviceStageOnDeviceConnect
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_LaunchDeviceStageFromExplorer">
            <summary>
                DEVPKEY_DeviceContainer_LaunchDeviceStageFromExplorer
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_BaselineExperienceId">
            <summary>
                DEVPKEY_DeviceContainer_BaselineExperienceId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsDeviceUniquelyIdentifiable">
            <summary>
                DEVPKEY_DeviceContainer_IsDeviceUniquelyIdentifiable
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_AssociationArray">
            <summary>
                DEVPKEY_DeviceContainer_AssociationArray
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_DeviceDescription1">
            <summary>
                DEVPKEY_DeviceContainer_DeviceDescription1
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_DeviceDescription2">
            <summary>
                DEVPKEY_DeviceContainer_DeviceDescription2
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_HasProblem">
            <summary>
                DEVPKEY_DeviceContainer_HasProblem
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsSharedDevice">
            <summary>
                DEVPKEY_DeviceContainer_IsSharedDevice
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsNetworkDevice">
            <summary>
                DEVPKEY_DeviceContainer_IsNetworkDevice
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsDefaultDevice">
            <summary>
                DEVPKEY_DeviceContainer_IsDefaultDevice
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_MetadataCabinet">
            <summary>
                DEVPKEY_DeviceContainer_MetadataCabinet
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_RequiresPairingElevation">
            <summary>
                DEVPKEY_DeviceContainer_RequiresPairingElevation
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_ExperienceId">
            <summary>
                DEVPKEY_DeviceContainer_ExperienceId
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_Category">
            <summary>
                DEVPKEY_DeviceContainer_Category
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_Category_Desc_Singular">
            <summary>
                DEVPKEY_DeviceContainer_Category_Desc_Singular
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_Category_Desc_Plural">
            <summary>
                DEVPKEY_DeviceContainer_Category_Desc_Plural
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_Category_Icon">
            <summary>
                DEVPKEY_DeviceContainer_Category_Icon
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_CategoryGroup_Desc">
            <summary>
                DEVPKEY_DeviceContainer_CategoryGroup_Desc
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_CategoryGroup_Icon">
            <summary>
                DEVPKEY_DeviceContainer_CategoryGroup_Icon
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_PrimaryCategory">
            <summary>
                DEVPKEY_DeviceContainer_PrimaryCategory
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_UnpairUninstall">
            <summary>
                DEVPKEY_DeviceContainer_UnpairUninstall
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_RequiresUninstallElevation">
            <summary>
                DEVPKEY_DeviceContainer_RequiresUninstallElevation
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_DeviceFunctionSubRank">
            <summary>
                DEVPKEY_DeviceContainer_DeviceFunctionSubRank
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_AlwaysShowDeviceAsConnected">
            <summary>
                DEVPKEY_DeviceContainer_AlwaysShowDeviceAsConnected
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_ConfigFlags">
            <summary>
                DEVPKEY_DeviceContainer_ConfigFlags
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_PrivilegedPackageFamilyNames">
            <summary>
                DEVPKEY_DeviceContainer_PrivilegedPackageFamilyNames
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_CustomPrivilegedPackageFamilyNames">
            <summary>
                DEVPKEY_DeviceContainer_CustomPrivilegedPackageFamilyNames
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_IsRebootRequired">
            <summary>
                DEVPKEY_DeviceContainer_IsRebootRequired
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_FriendlyName">
            <summary>
                DEVPKEY_DeviceContainer_FriendlyName
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_Manufacturer">
            <summary>
                DEVPKEY_DeviceContainer_Manufacturer
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_ModelNumber">
            <summary>
                DEVPKEY_DeviceContainer_ModelNumber
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DeviceContainer_InstallInProgress">
            <summary>
                DEVPKEY_DeviceContainer_InstallInProgress
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey.DevQuery_ObjectType">
            <summary>
                DEVPKEY_DevQuery_ObjectType
            </summary>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.CustomDeviceProperty">
            <summary>
                Describes a custom device property.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.CustomDeviceProperty.CreateCustomDeviceProperty(System.Guid,System.UInt32,System.Type)">
            <summary>
                Creates a custom device property.
            </summary>
            <param name="categoryGuid">The category GUID.</param>
            <param name="propertyIdentifier">The property identifier.</param>
            <param name="propertyType">The managed type to translate from/to.</param>
            <returns>A new instance of <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.CustomDeviceProperty" />.</returns>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener">
            <summary>
                Utility class to listen for system-wide device arrivals and removals based on a provided device interface GUID.
            </summary>
            <remarks>Original source: https://gist.github.com/emoacht/73eff195317e387f4cda</remarks>
        </member>
        <member name="E:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.DeviceArrived">
            <summary>
                Gets invoked when a new device has arrived (plugged in).
            </summary>
        </member>
        <member name="E:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.DeviceRemoved">
            <summary>
                Gets invoked when an existing device has been removed (unplugged).
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.StartListen(System.Guid)">
            <summary>
                Start listening for device arrivals/removals using the provided <see cref="T:System.Guid" />. Call this after you've
                subscribed to <see cref="E:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.DeviceArrived" /> and <see cref="E:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.DeviceRemoved" /> events.
            </summary>
            <param name="interfaceGuid">The device interface GUID to listen for.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.StopListen(System.Nullable{System.Guid})">
            <summary>
                Stop listening. The events <see cref="E:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.DeviceArrived" /> and <see cref="E:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.DeviceRemoved" /> will not get invoked
                anymore after this call. If no <see cref="T:System.Guid" /> is specified, all currently registered interfaces will get
                unsubscribed.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.RegisterDeviceArrived(System.Action{Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs},System.Nullable{System.Guid})">
            <summary>
                Subscribe a custom event handler to device arrival events.
            </summary>
            <param name="handler">The event handler to invoke.</param>
            <param name="interfaceGuid">The interface GUID to get notified for or null to get notified for all listening GUIDs.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.UnregisterDeviceArrived(System.Action{Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs})">
            <summary>
                Unsubscribe a previously registered event handler.
            </summary>
            <param name="handler">The event handler to unsubscribe.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.RegisterDeviceRemoved(System.Action{Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs},System.Nullable{System.Guid})">
            <summary>
                Subscribe a custom event handler to device removal events.
            </summary>
            <param name="handler">The event handler to invoke.</param>
            <param name="interfaceGuid">The interface GUID to get notified for or null to get notified for all listening GUIDs.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IDeviceNotificationListener.UnregisterDeviceRemoved(System.Action{Nefarius.Utilities.DeviceManagement.PnP.DeviceEventArgs})">
            <summary>
                Unsubscribe a previously registered event handler.
            </summary>
            <param name="handler">The event handler to unsubscribe.</param>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice">
            <summary>
                Describes an instance of a PNP device.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstanceId">
            <summary>
                The instance ID of the device.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.DeviceId">
            <summary>
                The device ID.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.Parent">
            <summary>
                The parent of this <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice" />, if any.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.Siblings">
            <summary>
                Siblings of this <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice" /> sharing the same parent, if any.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.Children">
            <summary>
                Children of this <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice" />, if any.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.HardwareIds">
            <summary>
                List of hardware IDs, if any.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.CompatibleIds">
            <summary>
                List of compatible IDs, if any.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.Restart">
            <summary>
                Attempts to restart this device. Device restart may fail if it has open handles that currently can not be
                force-closed.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.Remove">
            <summary>
                Attempts to remove this device node.
            </summary>
            <remarks>
                This call DOES NOT invoke device and driver uninstall routines, as soon as the device is re-enumerated, it
                will reappear and become online.
            </remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.IsVirtual(System.Func{Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice,System.Boolean})">
            <summary>
                Walks up the <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" />s parents chain to determine if the top most device is root enumerated.
            </summary>
            <remarks>
                This is achieved by walking up the node tree until the top most parent and check if the last parent below the
                tree root is a software device. Hardware devices originate from a PCI(e) bus while virtual devices originate from a
                root enumerated device.
            </remarks>
            <param name="excludeIfMatches">Returns false if the given predicate is true.</param>
            <returns>True if this device originates from an emulator, false otherwise.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallNullDriver">
            <summary>
                Installs the NULL-driver on this device instance.
            </summary>
            <remarks>
                This will tear down the current device stack (no matter how many open handles exist), remove the existing function
                driver and reboot the device in "raw" or "driverless" mode. Some USB devices may require a port-cycle afterward
                for the change to take effect without requiring a reboot.
            </remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallNullDriver(System.Boolean@)">
            <summary>
                Installs the NULL-driver on this device instance.
            </summary>
            <remarks>
                This will tear down the current device stack (no matter how many open handles exist), remove the existing function
                driver and reboot the device in "raw" or "driverless" mode. Some USB devices may require a port-cycle afterward
                for the change to take effect without requiring a reboot.
            </remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallCustomDriver(System.String)">
            <summary>
                Installs a custom driver identified by the provided INF name on this device instance.
            </summary>
            <remarks>
                This method force-installs a given INF file on this device instance, even if no matching hardware or compatible IDs
                are found. This method can only succeed if <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallNullDriver" /> is called prior.
            </remarks>
            <param name="infName">
                The INF file name as found in C:\Windows\INF directory. It must be the name only, not a relative
                or absolute path.
            </param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallCustomDriver(System.String,System.Boolean@)">
            <summary>
                Installs a custom driver identified by the provided INF name on this device instance.
            </summary>
            <remarks>
                This method force-installs a given INF file on this device instance, even if no matching hardware or compatible IDs
                are found. This method can only succeed if <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallNullDriver" /> is called prior.
            </remarks>
            <param name="infName">
                The INF file name as found in C:\Windows\INF directory. It must be the name only, not a relative
                or absolute path.
            </param>
            <param name="rebootRequired">
                Gets whether a reboot is required for the changes to take effect or not.
            </param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.Uninstall">
            <summary>
                Uninstalls this device instance. Unlike <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.Remove" /> this call will unload and revert the device function
                driver to the best available compatible candidate on next device boot.
            </summary>
            <remarks>
                If this is used in combination with <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallNullDriver" /> or
                <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallCustomDriver(System.String)" />, you can call <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Refresh" /> afterwards to trigger device
                installation.
            </remarks>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.Uninstall(System.Boolean@)">
            <summary>
                Uninstalls this device instance. Unlike <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.Remove" /> this call will unload and revert the device function
                driver to the best available compatible candidate on next device boot.
            </summary>
            <remarks>
                If this is used in combination with <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallNullDriver" /> or
                <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.InstallCustomDriver(System.String)" />, you can call <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Refresh" /> afterwards to trigger device
                installation.
            </remarks>
            <param name="rebootRequired">
                Gets whether a reboot is required for the changes to take effect or not.
            </param>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.GetProperty``1(Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey)">
            <summary>
                Returns a device instance property identified by <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey" />.
            </summary>
            <typeparam name="T">The managed type of the fetched property value.</typeparam>
            <param name="propertyKey">The <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey" /> to query for.</param>
            <returns>On success, the value of the queried property.</returns>
            <remarks>If the queried property doesn't exist, the default value of the managed type is returned.</remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice.SetProperty``1(Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey,``0)">
            <summary>
                Creates or updates an existing property with a given value.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="propertyKey">The <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey" /> to update.</param>
            <param name="propertyValue">The value to set.</param>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice">
            <summary>
                Describes an instance of a PNP device.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Parent">
            <summary>
                The parent of this <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice" />, if any.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Siblings">
            <summary>
                Siblings of this <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice" /> sharing the same parent, if any.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Children">
            <summary>
                Children of this <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice" />, if any.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.HardwareIds">
            <summary>
                List of hardware IDs, if any.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.CompatibleIds">
            <summary>
                List of compatible IDs, if any.
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice._instanceHandle">
            <summary>
                A CfgMgr32-compatible handle of this device instance.
            </summary>
        </member>
        <member name="F:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice._locationFlags">
            <summary>
                The <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags" /> used when creating this instance.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.#ctor(System.String,Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags)">
            <summary>
                Creates a new <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" /> based on the supplied instance ID to search in the device tree.
            </summary>
            <param name="instanceId">The instance ID to look for.</param>
            <param name="flags">The <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags" /> influencing search behavior.</param>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.PnPDeviceNotFoundException">The desired device instance was not found on the system.</exception>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException">Device information lookup failed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The supplied <paramref name="flags"/> value was invalid.</exception>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstanceId">
            <summary>
                The instance ID of the device. Uniquely identifies devices of equal make and model on the same machine.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.DeviceId">
            <summary>
                The device ID. Typically built from the hardware ID of the same make and model of hardware.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Restart">
            <summary>
                Attempts to restart this device. Device restart may fail if it has open handles that currently can not be
                force-closed.
            </summary>
            <remarks>
                This method removes and re-enumerates (adds) the device note, which might cause unintended side effects. If
                this is the behaviour you seek, consider using <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.RemoveAndSetup" /> instead. This method remains here for
                backwards compatibility.
            </remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Remove">
            <summary>
                Attempts to remove this device node.
            </summary>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException">CM API failure occurred.</exception>
            <remarks>
                This call DOES NOT invoke device and driver uninstall routines, as soon as the device is re-enumerated, it
                will reappear and become online.
            </remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.IsVirtual(System.Func{Nefarius.Utilities.DeviceManagement.PnP.IPnPDevice,System.Boolean})">
            <summary>
                Walks up the <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" />s parents chain to determine if the top most device is root enumerated.
            </summary>
            <remarks>
                This is achieved by walking up the node tree until the top most parent and check if the last parent below the
                tree root is a software device. Hardware devices originate from a PCI(e) bus while virtual devices originate from a
                root enumerated device.
            </remarks>
            <param name="excludeIfMatches">Returns false if the given predicate is true.</param>
            <returns>True if this device originates from an emulator, false otherwise.</returns>
            <example>
            bool isVirtualDevice = pnpDevice.IsVirtual(pDevice =&gt;
            {
                List&lt;string&gt;? hardwareIds = pDevice.GetProperty&lt;string[]&gt;(DevicePropertyKey.Device_HardwareIds).ToList();
            
                // hardware IDs of root hubs/controllers that emit supported virtual devices as sources
                string[] excludedIds =
                {
            		@"ROOT\HIDGAMEMAP", // reWASD
            		@"ROOT\VHUSB3HC", // VirtualHere
            		@"Nefarius\ViGEmBus\Gen1", // ViGemBus v1 
            		@"Nefarius\ViGEmBus\Gen2", // ViGemBus v2 
            		@"Nefarius\VirtualPad" // VirtualPad
            	};
            
                return hardwareIds.Any(id =&gt; excludedIds.Contains(id.ToUpperInvariant()));
            });
            </example>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallNullDriver">
            <summary>
                Installs the NULL-driver on this device instance.
            </summary>
            <remarks>
                This will tear down the current device stack (no matter how many open handles exist), remove the existing function
                driver and reboot the device in "raw" or "driverless" mode. Some USB devices may require a port-cycle afterward
                for the change to take effect without requiring a reboot.
            </remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallNullDriver(System.Boolean@)">
            <summary>
                Installs the NULL-driver on this device instance.
            </summary>
            <remarks>
                This will tear down the current device stack (no matter how many open handles exist), remove the existing function
                driver and reboot the device in "raw" or "driverless" mode. Some USB devices may require a port-cycle afterward
                for the change to take effect without requiring a reboot.
            </remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallCustomDriver(System.String)">
            <summary>
                Installs a custom driver identified by the provided INF name on this device instance.
            </summary>
            <remarks>
                This method force-installs a given INF file on this device instance, even if no matching hardware or compatible IDs
                are found. This method can only succeed if <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallNullDriver" /> is called prior.
            </remarks>
            <param name="infName">
                The INF file name as found in C:\Windows\INF directory. It must be the name only, not a relative
                or absolute path.
            </param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallCustomDriver(System.String,System.Boolean@)">
            <summary>
                Installs a custom driver identified by the provided INF name on this device instance.
            </summary>
            <remarks>
                This method force-installs a given INF file on this device instance, even if no matching hardware or compatible IDs
                are found. This method can only succeed if <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallNullDriver" /> is called prior.
            </remarks>
            <param name="infName">
                The INF file name as found in C:\Windows\INF directory. It must be the name only, not a relative
                or absolute path.
            </param>
            <param name="rebootRequired">
                Gets whether a reboot is required for the changes to take effect or not.
            </param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Uninstall">
            <summary>
                Uninstalls this device instance. Unlike <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Remove" /> this call will unload and revert the device function
                driver to the best available compatible candidate on next device boot.
            </summary>
            <remarks>
                If this is used in combination with <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallNullDriver" /> or
                <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallCustomDriver(System.String)" />, you can call <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Refresh" /> afterwards to trigger device
                installation.
            </remarks>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Uninstall(System.Boolean@)">
            <summary>
                Uninstalls this device instance. Unlike <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Remove" /> this call will unload and revert the device function
                driver to the best available compatible candidate on next device boot.
            </summary>
            <remarks>
                If this is used in combination with <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallNullDriver" /> or
                <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.InstallCustomDriver(System.String)" />, you can call <see cref="M:Nefarius.Utilities.DeviceManagement.PnP.Devcon.Refresh" /> afterwards to trigger device
                installation.
            </remarks>
            <param name="rebootRequired">
                Gets whether a reboot is required for the changes to take effect or not.
            </param>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.Win32Exception"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.RemoveAndSetup">
            <summary>
                Attempts to restart this device by removing it from the device tree and causing re-enumeration afterwards.
            </summary>
            <remarks>Device restart may fail if it has open handles that currently can not be force-closed.</remarks>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException"></exception>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Disable">
            <summary>
                Disables this device instance node.
            </summary>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException"></exception>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Enable">
            <summary>
                Enables this device instance node.
            </summary>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException"></exception>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.ToString">
            <inheritdoc />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Equals(Nefarius.Utilities.DeviceManagement.PnP.PnPDevice)">
            <inheritdoc />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.op_Equality(Nefarius.Utilities.DeviceManagement.PnP.PnPDevice,Nefarius.Utilities.DeviceManagement.PnP.PnPDevice)">
            <summary>
                Compares two instances of <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" /> for equality.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.op_Inequality(Nefarius.Utilities.DeviceManagement.PnP.PnPDevice,Nefarius.Utilities.DeviceManagement.PnP.PnPDevice)">
            <summary>
                Compares two instances of <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" /> for equality.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.GetProperty``1(Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey)">
            <summary>
                Returns a device instance property identified by <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey" />.
            </summary>
            <typeparam name="T">The managed type of the fetched property value.</typeparam>
            <param name="propertyKey">The <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey" /> to query for.</param>
            <returns>On success, the value of the queried property.</returns>
            <remarks>If the queried property doesn't exist, the default value of the managed type is returned.</remarks>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.SetProperty``1(Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey,``0)">
            <summary>
                Creates or updates an existing property with a given value.
            </summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="propertyKey">The <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DevicePropertyKey" /> to update.</param>
            <param name="propertyValue">The value to set.</param>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.GetDeviceByInstanceId(System.String,Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags)">
            <summary>
                Return device identified by instance ID.
            </summary>
            <param name="instanceId">The instance ID of the device.</param>
            <param name="flags">
                <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags" />
            </param>
            <returns>A <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" />.</returns>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.PnPDeviceNotFoundException">The desired device instance was not found on the system.</exception>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException">Device information lookup failed.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The supplied <paramref name="flags"/> value was invalid.</exception>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.GetDeviceByInterfaceId(System.String,Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags)">
            <summary>
                Return device identified by instance ID/path (symbolic link).
            </summary>
            <param name="symbolicLink">The device interface path/ID/symbolic link name.</param>
            <param name="flags">
                <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.DeviceLocationFlags" />
            </param>
            <returns>A <see cref="T:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice" /> or null if not found.</returns>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException">Interface lookup failed.</exception>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.PnPDevice.GetInstanceIdFromInterfaceId(System.String)">
            <summary>
                Resolves Interface ID/Symbolic link/Device path to Instance ID.
            </summary>
            <param name="symbolicLink">The device interface path/ID/symbolic link name.</param>
            <returns>The Instance ID or null if not found.</returns>
            <exception cref="T:Nefarius.Utilities.DeviceManagement.Exceptions.ConfigManagerException">Interface lookup failed.</exception>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.SetupApi">
            <summary>
                SetupAPI imports.
            </summary>
            <example>https://learn.microsoft.com/en-us/windows-hardware/drivers/install/setupapi</example>
            <remarks>
                TODO: migrate over to CsWin32
            </remarks>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.PnP.UsbPnPDevice">
            <summary>
                Describes an instance of a USB PNP device.
            </summary>
        </member>
        <member name="P:Nefarius.Utilities.DeviceManagement.PnP.UsbPnPDevice.Port">
            <summary>
                The port number/index of this device on its root hub.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.PnP.UsbPnPDevice.CyclePort">
            <summary>
                Power-cycles the hub port this device is attached to, causing it to restart.
            </summary>
            <remarks>Requires administrative privileges.</remarks>
        </member>
        <member name="T:Nefarius.Utilities.DeviceManagement.Util.NtStatusUtil">
            <summary>
                Utility methods for handling NTSTATUS values.
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Util.NtStatusUtil.ConvertNtStatusToWin32Error(System.UInt32)">
            <summary>
                Converts an NTSTATUS value to a <see cref="T:Windows.Win32.Foundation.WIN32_ERROR" />.
            </summary>
            <remarks>Source: https://stackoverflow.com/a/32205631</remarks>
            <param name="ntStatus">The NTSTATUS value to convert.</param>
            <returns>The converted Win32 error code.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Util.NtStatusUtil.GetOverlappedResult(System.IntPtr,System.Threading.NativeOverlapped*,System.Int32@,System.Boolean)">
            <summary>
                The CsWin32-generated variant doesn't allow for an empty file handle so we gotta cheat a bit :)
            </summary>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Util.StringConversionExtensions.StringArrayToMultiSzPointer(System.Collections.Generic.IEnumerable{System.String},System.Int32@)">
            <summary>
                Converts an array of <see cref="T:System.String" /> into a double-null-terminated multi-byte character memory block.
            </summary>
            <param name="instances">Source array of strings.</param>
            <param name="length">The length of the resulting byte array.</param>
            <returns>The allocated memory buffer.</returns>
        </member>
        <member name="M:Nefarius.Utilities.DeviceManagement.Util.StringConversionExtensions.MultiSzPointerToStringArray(System.IntPtr,System.Int32)">
            <summary>
                Converts a double-null-terminated multi-byte character memory block into a string array.
            </summary>
            <param name="buffer">The memory buffer.</param>
            <param name="length">The size in bytes of the memory buffer.</param>
            <returns>The extracted string array.</returns>
        </member>
        <member name="T:Windows.Win32.Foundation.FILETIME">
            <summary>Describes FILETIME and provides syntax, members, and additional remarks.</summary>
            <remarks>
            <para>A property of type PT_SYSTIME has a **FILETIME** structure for its value. Such a property has a **FILETIME** data type for the **Value** member in its definition in an [SPropValue](spropvalue.md) structure. The definition of the **FILETIME** structure is in the _Win32 Programmer's Reference_ and in the MAPI header file Mapidefs.h. MAPI defines the structure conditionally to make sure that it is defined when the Win32 definition is unavailable.</para>
            <para><see href="https://learn.microsoft.com/office/client-developer/outlook/mapi/filetime#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Foundation.FILETIME.dwLowDateTime">
            <summary>> Low-order 32 bits of the file time value.</summary>
        </member>
        <member name="F:Windows.Win32.Foundation.FILETIME.dwHighDateTime">
            <summary>> High-order 32 bits of the file time value.</summary>
        </member>
        <member name="T:Windows.Win32.Foundation.PCSTR">
            <summary>
            A pointer to a null-terminated, constant, ANSI character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, decoding as UTF-8.
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.PCWSTR">
            <summary>
            A pointer to a null-terminated, constant character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCWSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCWSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, up to the first null character (exclusive).
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCWSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.PCZZWSTR">
            <summary>
            A pointer to a constant, empty-string terminated list of null-terminated strings that uses UTF-16 encoding.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCZZWSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCZZWSTR.Length">
            <summary>
            Gets the number of characters in this null-terminated string list, excluding the final null terminator.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCZZWSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array.
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCZZWSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCZZWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PWSTR.ToString">
            <inheritdoc cref="M:Windows.Win32.Foundation.PCWSTR.ToString"/>
        </member>
        <member name="P:Windows.Win32.Foundation.PWSTR.Length">
            <inheritdoc cref="P:Windows.Win32.Foundation.PCWSTR.Length"/>
        </member>
        <member name="M:Windows.Win32.Foundation.PWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.PZZWSTR">
            <summary>
            A pointer to an empty-string terminated list of null-terminated strings that uses UTF-16 encoding.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PZZWSTR.Value">
            <summary>
            A pointer to the first character in the string.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PZZWSTR.Length">
            <inheritdoc cref="P:Windows.Win32.Foundation.PCZZWSTR.Length"/>
        </member>
        <member name="M:Windows.Win32.Foundation.PZZWSTR.ToString">
            <inheritdoc cref="M:Windows.Win32.Foundation.PCZZWSTR.ToString"/>
        </member>
        <member name="M:Windows.Win32.Foundation.PZZWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string.
            </summary>
        </member>
        <member name="T:Windows.Win32.CloseServiceHandleSafeHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:Windows.Win32.PInvoke.CloseServiceHandle(Windows.Win32.System.Services.SC_HANDLE)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE">
            <summary>If the PnP manager rejects a request to perform an operation, the PNP_VETO_TYPE enumeration is used to identify the reason for the rejection.</summary>
            <remarks>
            <para>Text strings are associated with most of the veto types, and a function that receives a veto type value can typically request to also receive the value's associated text string. The following table identifies the text string associated with each value. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfg/ne-cfg-pnp_veto_type#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoTypeUnknown">
            <summary>The specified operation was rejected for an unknown reason.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoLegacyDevice">
            <summary>The device does not support the specified PnP operation.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoPendingClose">
            <summary>The specified operation cannot be completed because of a pending close operation.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoWindowsApp">
            <summary>A Microsoft Win32 application vetoed the specified operation.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoWindowsService">
            <summary>A Win32 service vetoed the specified operation.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoOutstandingOpen">
            <summary>The requested operation was rejected because of outstanding open handles.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoDevice">
            <summary>The device supports the specified operation, but the device rejected the operation.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoDriver">
            <summary>The driver supports the specified operation, but the driver rejected the operation.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoIllegalDeviceRequest">
            <summary>The device does not support the specified operation.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoInsufficientPower">
            <summary>There is insufficient power to perform the requested operation.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoNonDisableable">
            <summary>The device cannot be disabled.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoLegacyDriver">
            <summary>The driver does not support the specified PnP operation.</summary>
        </member>
        <member name="F:Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE.PNP_VetoInsufficientRights">
            <summary>The caller has insufficient privileges to complete the operation.</summary>
        </member>
        <member name="T:Windows.Win32.UI.WindowsAndMessaging.MSG">
            <summary>Contains message information from a thread's message queue.</summary>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.hwnd">
            <summary>
            <para>Type: <b>HWND</b> A handle to the window whose window procedure receives the message. This member is <b>NULL</b> when the message is a thread message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.message">
            <summary>
            <para>Type: <b>UINT</b> The message identifier. Applications can only use the low word; the high word is reserved by the system.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.wParam">
            <summary>
            <para>Type: <b>WPARAM</b> Additional information about the message. The exact meaning depends on the value of the <b>message</b> member.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.lParam">
            <summary>
            <para>Type: <b>LPARAM</b> Additional information about the message. The exact meaning depends on the value of the <b>message</b> member.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.time">
            <summary>
            <para>Type: <b>DWORD</b> The time at which the message was posted.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.MSG.pt">
            <summary>
            <para>Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b> The cursor position, in screen coordinates, when the message was posted.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-msg#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW">
            <summary>Contains window class information. (Unicode)</summary>
            <remarks>
            <para>> [!NOTE] > The winuser.h header defines WNDCLASSEX as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.cbSize">
            <summary>
            <para>Type: <b>UINT</b> The size, in bytes, of this structure. Set this member to <c>sizeof(WNDCLASSEX)</c>. Be sure to set this member before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.style">
            <summary>
            <para>Type: <b>UINT</b> The class style(s). This member can be any combination of the <a href="https://docs.microsoft.com/windows/win32/winmsg/window-class-styles">Class Styles</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.lpfnWndProc">
            <summary>
            <para>Type: <b>WNDPROC</b> A pointer to the window procedure. You must use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a> function to call the window procedure. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.cbClsExtra">
            <summary>
            <para>Type: <b>int</b> The number of extra bytes to allocate following the window-class structure. The system initializes the bytes to zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.cbWndExtra">
            <summary>
            <para>Type: <b>int</b> The number of extra bytes to allocate following the window instance. The system initializes the bytes to zero. If an application uses <b>WNDCLASSEX</b> to register a dialog box created by using the <b>CLASS</b> directive in the resource file, it must set this member to <b>DLGWINDOWEXTRA</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.hInstance">
            <summary>
            <para>Type: <b>HINSTANCE</b> A handle to the instance that contains the window procedure for the class.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.hIcon">
            <summary>
            <para>Type: <b>HICON</b> A handle to the class icon. This member must be a handle to an icon resource. If this member is <b>NULL</b>, the system provides a default icon.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.hCursor">
            <summary>
            <para>Type: <b>HCURSOR</b> A handle to the class cursor. This member must be a handle to a cursor resource. If this member is <b>NULL</b>, an application must explicitly set the cursor shape whenever the mouse moves into the application's window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.hbrBackground">
            <summary>
            <para>Type: <b>HBRUSH</b> A handle to the class background brush. This member can be a handle to the brush to be used for painting the background, or it can be a color value. A color value must be one of the following standard system colors (the value 1 must be added to the chosen color). If a color value is given, you must convert it to one of the following <b>HBRUSH</b> types: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.lpszMenuName">
            <summary>
            <para>Type: <b>LPCTSTR</b> Pointer to a null-terminated character string that specifies the resource name of the class menu, as the name appears in the resource file. If you use an integer to identify the menu, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro. If this member is <b>NULL</b>, windows belonging to this class have no default menu.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.lpszClassName">
            <summary>
            <para>Type: <b>LPCTSTR</b> A pointer to a null-terminated string or is an atom. If this parameter is an atom, it must be a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <b>lpszClassName</b>; the high-order word must be zero.</para>
            <para>If <b>lpszClassName</b> is a string, it specifies the window class name. The class name can be any name registered with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names. The maximum length for <b>lpszClassName</b> is 256. If <b>lpszClassName</b> is greater than the maximum length, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function will fail.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW.hIconSm">
            <summary>
            <para>Type: <b>HICON</b> A handle to a small icon that is associated with the window class. If this member is <b>NULL</b>, the system searches the icon resource specified by the <b>hIcon</b> member for an icon of the appropriate size to use as the small icon.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/ns-winuser-wndclassexw#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.UI.Shell.PropertiesSystem.PROPERTYKEY">
            <summary>Specifies the FMTID/PID identifier that programmatically identifies a property. Replaces SHCOLUMNID.</summary>
            <remarks>
            <para>As of Windows Vista, the <a href="https://docs.microsoft.com/windows/desktop/shell/objects">SHCOLUMNID</a> structure is simply an alias for <a href="https://docs.microsoft.com/windows/desktop/api/wtypes/ns-wtypes-propertykey">PROPERTYKEY</a>, as shown in this declaration from Shobjidl.h.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypes/ns-wtypes-propertykey#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.UI.Shell.PropertiesSystem.PROPERTYKEY.fmtid">
            <summary>
            <para>Type: <b>GUID</b> A unique GUID for the property.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypes/ns-wtypes-propertykey#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.UI.Shell.PropertiesSystem.PROPERTYKEY.pid">
            <summary>
            <para>Type: <b>DWORD</b> A property identifier (PID). This parameter is not used as in <a href="https://docs.microsoft.com/windows/desktop/shell/objects">SHCOLUMNID</a>. It is recommended that you set this value to PID_FIRST_USABLE. Any value greater than or equal to 2 is acceptable. <div class="alert"><b>Note</b>  Values of 0 and 1 are reserved and should not be used.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypes/ns-wtypes-propertykey#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.FreeLibrarySafeHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:Windows.Win32.PInvoke.FreeLibrary(Windows.Win32.Foundation.HMODULE)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.LocalFreeSafeHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:Windows.Win32.PInvoke.LocalFree(Windows.Win32.Foundation.HLOCAL)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.PInvoke">
            <content>
            Contains extern methods from "ADVAPI32.dll".
            </content>
            <content>
            Contains extern methods from "CFGMGR32.dll".
            </content>
            <content>
            Contains extern methods from "GDI32.dll".
            </content>
            <content>
            Contains extern methods from "HID.dll".
            </content>
            <content>
            Contains extern methods from "KERNEL32.dll".
            </content>
            <content>
            Contains extern methods from "newdev.dll".
            </content>
            <content>
            Contains extern methods from "SETUPAPI.dll".
            </content>
            <content>
            Contains extern methods from "USER32.dll".
            </content>
        </member>
        <member name="M:Windows.Win32.PInvoke.CloseServiceHandle(Windows.Win32.System.Services.SC_HANDLE)">
            <summary>Closes a handle to a service control manager or service object.</summary>
            <param name="hSCObject">
            <para>A handle to the service control manager object or the service object to close. Handles to service control manager objects are returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openscmanagera">OpenSCManager</a> function, and handles to service objects are returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openservicea">OpenService</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-closeservicehandle#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error code can be set by the service control manager. Other error codes can be set by registry functions that are called by the service control manager. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The <b>CloseServiceHandle</b> function does not destroy the service control manager object referred to by the handle. A service control manager object cannot be destroyed. A service object can be destroyed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-deleteservice">DeleteService</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-closeservicehandle#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.OpenSCManager(System.String,System.String,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.OpenSCManager(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.OpenSCManager(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,System.UInt32)">
            <summary>Establishes a connection to the service control manager on the specified computer and opens the specified service control manager database. (Unicode)</summary>
            <param name="lpMachineName">The name of the target computer. If the pointer is NULL or points to an empty string, the function connects to the service control manager on the local computer.</param>
            <param name="lpDatabaseName">The name of the service control manager database. This parameter should be set to SERVICES_ACTIVE_DATABASE. If it is NULL, the SERVICES_ACTIVE_DATABASE database is opened by default.</param>
            <param name="dwDesiredAccess">
            <para>The access to the service control manager. For a list of access rights, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
            <para>Before granting the requested access rights, the system checks the access token of the calling process against the discretionary access-control list of the security descriptor associated with the service control manager. The SC_MANAGER_CONNECT access right is implicitly specified by calling this function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openscmanagerw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the specified service control manager database. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes can be set by the SCM. Other error codes can be set by the registry functions that are called by the SCM. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>When a process uses the <b>OpenSCManager</b> function to open a handle to a service control manager database, the system performs a security check before granting the requested access. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>. If the current user does not have proper access when connecting to a service on another computer, the  <b>OpenSCManager</b> function call fails. To connect to a service remotely, call the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-logonusera">LogonUser</a> function with LOGON32_LOGON_NEW_CREDENTIALS and then call <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser">ImpersonateLoggedOnUser</a> before calling <b>OpenSCManager</b>. For more information about connecting to services remotely, see <a href="https://docs.microsoft.com/windows/desktop/Services/services-and-rpc-tcp">Services and RPC/TCP</a>. Only processes with Administrator privileges are able to open a database handle that can be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function. The returned handle is only valid for the process that called the <b>OpenSCManager</b> function. It can be closed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-closeservicehandle">CloseServiceHandle</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openscmanagerw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.OpenService(System.Runtime.InteropServices.SafeHandle,System.String,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.OpenService(Windows.Win32.System.Services.SC_HANDLE,Windows.Win32.Foundation.PCWSTR,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.OpenService(Windows.Win32.System.Services.SC_HANDLE,Windows.Win32.Foundation.PCWSTR,System.UInt32)">
            <summary>Opens an existing service. (Unicode)</summary>
            <param name="hSCManager">
            <para>A handle to the service control manager database. The <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-openscmanagera">OpenSCManager</a> function returns this handle. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openservicew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpServiceName">
            <para>The name of the service to be opened. This is the name specified by the <i>lpServiceName</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-createservicea">CreateService</a> function when the service object was created, not the service display name that is shown by user interface applications to identify the service. The maximum string length is 256 characters. The service control manager database preserves the case of the characters, but service name comparisons are always case insensitive. Forward-slash (/) and backslash (\\) are invalid service name characters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openservicew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwDesiredAccess">
            <para>The access to the service. For a list of access rights, see <a href="https://docs.microsoft.com/windows/desktop/Services/service-security-and-access-rights">Service Security and Access Rights</a>.</para>
            <para>Before granting the requested access, the system checks the access token of the calling process against the discretionary access-control list of the security descriptor associated with the service object.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openservicew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the service. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following error codes can be set by the service control manager. Others can be set by the registry functions that are called by the service control manager. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The returned handle is only valid for the process that called <b>OpenService</b>. It can be closed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nf-winsvc-closeservicehandle">CloseServiceHandle</a> function. To use <b>OpenService</b>, no privileges are required aside from <b>SC_MANAGER_CONNECT</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openservicew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegCloseKey(Windows.Win32.System.Registry.HKEY)">
            <summary>Closes a handle to the specified registry key.</summary>
            <param name="hKey">
            <para>A handle to the open key to be closed. The handle must have been opened by the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeyexa">RegCreateKeyEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeytransacteda">RegCreateKeyTransacted</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeyexa">RegOpenKeyEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeytransacteda">RegOpenKeyTransacted</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regconnectregistrya">RegConnectRegistry</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error.</para>
            </returns>
            <remarks>
            <para>The handle for a specified key should not be used after it has been closed, because it will no longer be valid. Key handles should not be left open any longer than necessary. The <b>RegCloseKey</b> function does not necessarily write information to the registry before returning; it can take as much as several seconds for the cache to be flushed to the hard disk. If an application must explicitly write registry information to the hard disk, it can use the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regflushkey">RegFlushKey</a> function. <b>RegFlushKey</b>, however, uses many system resources and should be called only when necessary.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegDeleteValue(System.Runtime.InteropServices.SafeHandle,System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.RegDeleteValue(Windows.Win32.System.Registry.HKEY,Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegDeleteValue(Windows.Win32.System.Registry.HKEY,Windows.Win32.Foundation.PCWSTR)">
            <summary>Removes a named value from the specified registry key. (Unicode)</summary>
            <param name="hKey">
            <para>A handle to an open registry key. The key must have been opened with the KEY_SET_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
            <para>This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeyexa">RegCreateKeyEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeytransacteda">RegCreateKeyTransacted</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeyexa">RegOpenKeyEx</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeytransacteda">RegOpenKeyTransacted</a> function. It can also be one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:</para>
            <para><pre><b></b> <b>HKEY_CLASSES_ROOT</b> <b>HKEY_CURRENT_CONFIG</b> <b>HKEY_CURRENT_USER</b> <b>HKEY_LOCAL_MACHINE</b> <b>HKEY_USERS</b></pre></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regdeletevaluew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpValueName">
            <para>The registry value to be removed. If this parameter is <b>NULL</b> or an empty string, the value set by the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regsetvaluea">RegSetValue</a> function is removed.</para>
            <para>For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-element-size-limits">Registry Element Size Limits</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regdeletevaluew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error.</para>
            </returns>
            <remarks>
            <para>> [!NOTE] > The winreg.h header defines RegDeleteValue as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regdeletevaluew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegQueryValueEx(System.Runtime.InteropServices.SafeHandle,System.String,Windows.Win32.System.Registry.REG_VALUE_TYPE*,System.Byte*,System.UInt32*)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.RegQueryValueEx(Windows.Win32.System.Registry.HKEY,Windows.Win32.Foundation.PCWSTR,System.UInt32*,Windows.Win32.System.Registry.REG_VALUE_TYPE*,System.Byte*,System.UInt32*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegQueryValueEx(Windows.Win32.System.Registry.HKEY,Windows.Win32.Foundation.PCWSTR,System.UInt32*,Windows.Win32.System.Registry.REG_VALUE_TYPE*,System.Byte*,System.UInt32*)">
            <summary>Retrieves the type and data for the specified value name associated with an open registry key. (Unicode)</summary>
            <param name="hKey">
            <para>A handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-key-security-and-access-rights">Registry Key Security and Access Rights</a>.</para>
            <para>This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeyexa">RegCreateKeyEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regcreatekeytransacteda">RegCreateKeyTransacted</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeyexa">RegOpenKeyEx</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regopenkeytransacteda">RegOpenKeyTransacted</a> function. It can also be one of the following <a href="https://docs.microsoft.com/windows/desktop/SysInfo/predefined-keys">predefined keys</a>:<dl> <dd><b>HKEY_CLASSES_ROOT</b></dd> <dd><b>HKEY_CURRENT_CONFIG</b></dd> <dd><b>HKEY_CURRENT_USER</b></dd> <dd><b>HKEY_LOCAL_MACHINE</b></dd> <dd><b>HKEY_PERFORMANCE_DATA</b></dd> <dd><b>HKEY_PERFORMANCE_NLSTEXT</b></dd> <dd><b>HKEY_PERFORMANCE_TEXT</b></dd> <dd><b>HKEY_USERS</b></dd> </dl></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regqueryvalueexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpValueName">
            <para>The name of the registry value.</para>
            <para>If <i>lpValueName</i> is <b>NULL</b> or an empty string, "", the function retrieves the type and data for the key's unnamed or default value, if any. If <i>lpValueName</i> specifies a value that is not in the registry, the function returns ERROR_FILE_NOT_FOUND. Keys do not automatically have an unnamed or default value. Unnamed values can be of any type. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-element-size-limits">Registry Element Size Limits</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regqueryvalueexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpReserved">This parameter is reserved and must be <b>NULL</b>.</param>
            <param name="lpType">
            <para>A pointer to a variable that receives a code indicating the type of data stored in the specified value. For a list of the possible type codes, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-value-types">Registry Value Types</a>. The <i>lpType</i> parameter can be <b>NULL</b> if the type code is not required.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regqueryvalueexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpData">A pointer to a buffer that receives the value's data. This parameter can be <b>NULL</b> if the data is not required.</param>
            <param name="lpcbData">
            <para>A pointer to a variable that specifies the size of the buffer pointed to by the <i>lpData</i> parameter, in bytes. When the function returns, this variable contains the size of the data copied to <i>lpData</i>.</para>
            <para>The <i>lpcbData</i> parameter can be <b>NULL</b> only if <i>lpData</i> is <b>NULL</b>. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, this size includes any terminating <b>null</b> character or characters unless the data was stored without them. For more information, see Remarks. If the buffer specified by <i>lpData</i> parameter is not large enough to hold the data, the function returns ERROR_MORE_DATA and stores the required buffer size in the variable pointed to by <i>lpcbData</i>. In this case, the contents of the <i>lpData</i> buffer are undefined. If <i>lpData</i> is <b>NULL</b>, and <i>lpcbData</i> is non-<b>NULL</b>, the function returns ERROR_SUCCESS and stores the size of the data, in bytes, in the variable pointed to by <i>lpcbData</i>. This enables an application to determine the best way to allocate a buffer for the value's data. If <i>hKey</i> specifies <b>HKEY_PERFORMANCE_DATA</b> and the <i>lpData</i> buffer is not large enough to contain all of the returned data, <b>RegQueryValueEx</b> returns ERROR_MORE_DATA and the value returned through the <i>lpcbData</i> parameter is undefined. This is because the size of the performance data can change from one call to the next. In this case, you must increase the buffer size and call <b>RegQueryValueEx</b> again passing the updated buffer size in the <i>lpcbData</i> parameter. Repeat this until the function succeeds. You need to maintain a separate variable to keep track of the buffer size, because the value returned by <i>lpcbData</i> is unpredictable. If the <i>lpValueName</i> registry value does not exist, <b>RegQueryValueEx</b> returns ERROR_FILE_NOT_FOUND and the value returned through the <i>lpcbData</i> parameter is undefined.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regqueryvalueexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">system error code</a>. If the <i>lpData</i> buffer is too small to receive the data, the function returns ERROR_MORE_DATA. If the <i>lpValueName</i> registry value does not exist, the function returns ERROR_FILE_NOT_FOUND.</para>
            </returns>
            <remarks>
            <para>An application typically calls <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-regenumvaluea">RegEnumValue</a> to determine the value names and then <b>RegQueryValueEx</b> to retrieve the data for the names. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, the string may not have been stored with the proper terminating <b>null</b> characters. Therefore, even if the function returns ERROR_SUCCESS, the application should ensure that the string is properly terminated before using it; otherwise, it may overwrite a buffer. (Note that REG_MULTI_SZ strings should have two terminating <b>null</b> characters.) One way an application can ensure that the string is properly terminated is to use <a href="https://docs.microsoft.com/windows/desktop/api/winreg/nf-winreg-reggetvaluea">RegGetValue</a>, which adds terminating <b>null</b> characters if needed. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, and the ANSI version of this function is used (either by explicitly calling <b>RegQueryValueExA</b> or by not defining UNICODE before including the Windows.h file), this function converts the stored Unicode string to an ANSI string before copying it to the buffer pointed to by <i>lpData</i>. When calling the <b>RegQueryValueEx</b> function with <i>hKey</i> set to the <b>HKEY_PERFORMANCE_DATA</b> handle and a value string of a specified object, the returned data structure sometimes has unrequested objects. Do not be surprised; this is normal behavior. When calling the <b>RegQueryValueEx</b> function, you should always expect to walk the returned data structure to look for the requested object. Note that operations that access certain registry keys are redirected. For more information,  see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/registry-virtualization">Registry Virtualization</a> and <a href="https://docs.microsoft.com/windows/desktop/SysInfo/32-bit-and-64-bit-application-data-in-the-registry">32-bit and 64-bit Application Data in the Registry</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winreg/nf-winreg-regqueryvalueexw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegSetValueEx(System.Runtime.InteropServices.SafeHandle,System.String,Windows.Win32.System.Registry.REG_VALUE_TYPE,System.ReadOnlySpan{System.Byte})">
            <inheritdoc cref="M:Windows.Win32.PInvoke.RegSetValueEx(Windows.Win32.System.Registry.HKEY,Windows.Win32.Foundation.PCWSTR,System.UInt32,Windows.Win32.System.Registry.REG_VALUE_TYPE,System.Byte*,System.UInt32)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Windows.Win32.PInvoke.RegSetValueEx(Windows.Win32.System.Registry.HKEY,Windows.Win32.Foundation.PCWSTR,System.UInt32,Windows.Win32.System.Registry.REG_VALUE_TYPE,System.Byte*,System.UInt32)" -->
        <member name="M:Windows.Win32.PInvoke.CM_Disable_DevNode(System.UInt32,System.UInt32)">
            <summary>The CM_Disable_DevNode function disables a device.</summary>
            <param name="dnDevInst">Device instance handle that is bound to the local machine.</param>
            <param name="ulFlags">Disable flags:</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks>By default, <b>CM_Disable_DevNode</b> disables a device at one time, but after reboot the device is enabled again. Starting in Windows 10, you can specify the <b>CM_DISABLE_PERSIST</b> flag to disable the device across reboots.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Enable_DevNode(System.UInt32,System.UInt32)">
            <summary>The CM_Enable_DevNode function enables a device.</summary>
            <param name="dnDevInst">Device instance handle that is bound to the local machine.</param>
            <param name="ulFlags">Reserved. Must be set to zero.</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_enable_devnode">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_DevNode_Property(System.UInt32,Windows.Win32.Devices.Properties.DEVPROPKEY@,Windows.Win32.Devices.Properties.DEVPROPTYPE@,System.Byte*,System.UInt32@,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Get_DevNode_Property(System.UInt32,Windows.Win32.Devices.Properties.DEVPROPKEY*,Windows.Win32.Devices.Properties.DEVPROPTYPE*,System.Byte*,System.UInt32*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_DevNode_Property(System.UInt32,Windows.Win32.Devices.Properties.DEVPROPKEY*,Windows.Win32.Devices.Properties.DEVPROPTYPE*,System.Byte*,System.UInt32*,System.UInt32)">
            <summary>The CM_Get_DevNode_Property function retrieves a device instance property.</summary>
            <param name="dnDevInst">Device instance handle that is bound to the local machine.</param>
            <param name="PropertyKey">Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device property key of the requested device instance property.</param>
            <param name="PropertyType">Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device instance property, where the property-data-type identifier is the bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.</param>
            <param name="PropertyBuffer">Pointer to a buffer that receives the requested device instance property. <b>CM_Get_DevNode_Property</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.</param>
            <param name="PropertyBufferSize">The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_DevNode_Property</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.</param>
            <param name="ulFlags">Reserved. Must be set to zero.</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks><b>CM_Get_DevNode_Property</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_IDW(System.UInt32,System.Span{System.Char},System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Get_Device_IDW(System.UInt32,Windows.Win32.Foundation.PWSTR,System.UInt32,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_IDW(System.UInt32,Windows.Win32.Foundation.PWSTR,System.UInt32,System.UInt32)">
            <summary>The CM_Get_Device_ID function retrieves the device instance ID for a specified device instance on the local machine. (Unicode)</summary>
            <param name="dnDevInst">Caller-supplied device instance handle that is bound to the local machine.</param>
            <param name="Buffer">Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size">CM_Get_Device_ID_Size</a>, then incrementing the received value to allow room for the string's terminating <b>NULL</b>.</param>
            <param name="BufferLen">Caller-supplied length, in characters, of the buffer specified by <i>Buffer</i>.</param>
            <param name="ulFlags">Not used, must be zero.</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks>
            <para>The function appends a NULL terminator to the supplied device instance ID string, unless the buffer is too small to hold the string. In this case, the function supplies as much of the identifier string as will fit into the buffer, and then returns CR_BUFFER_SMALL. For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>. For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_idw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_ID_Size(System.UInt32@,System.UInt32,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Get_Device_ID_Size(System.UInt32*,System.UInt32,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_ID_Size(System.UInt32*,System.UInt32,System.UInt32)">
            <summary>The CM_Get_Device_ID_Size function retrieves the buffer size required to hold a device instance ID for a device instance on the local machine.</summary>
            <param name="pulLen">Receives a value representing the required buffer size, in characters.</param>
            <param name="dnDevInst">Caller-supplied device instance handle that is bound to the local machine.</param>
            <param name="ulFlags">Not used, must be zero.</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks>
            <para>The <b>CM_Get_Device_ID_Size</b> function should be called to determine the buffer size required by <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_idw">CM_Get_Device_ID</a>. The size value supplied in the location pointed to by <i>pulLen</i> is less than MAX_DEVICE_ID_LEN, and does not include the identifier string's terminating <b>NULL</b>. If the specified device instance does not exist, the function supplies a size value of zero. For information about device instance IDs, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>. For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_id_size#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_Interface_List(System.Guid@,Windows.Win32.Foundation.PWSTR,Windows.Win32.Foundation.PZZWSTR,System.UInt32,Windows.Win32.Devices.DeviceAndDriverInstallation.CM_GET_DEVICE_INTERFACE_LIST_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Get_Device_Interface_List(System.Guid*,Windows.Win32.Foundation.PWSTR,Windows.Win32.Foundation.PZZWSTR,System.UInt32,Windows.Win32.Devices.DeviceAndDriverInstallation.CM_GET_DEVICE_INTERFACE_LIST_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_Interface_List(System.Guid*,Windows.Win32.Foundation.PWSTR,Windows.Win32.Foundation.PZZWSTR,System.UInt32,Windows.Win32.Devices.DeviceAndDriverInstallation.CM_GET_DEVICE_INTERFACE_LIST_FLAGS)">
            <summary>The CM_Get_Device_Interface_List function retrieves a list of device interface instances that belong to a specified device interface class. (Unicode)</summary>
            <param name="InterfaceClassGuid">Supplies a GUID that identifies a device interface class.</param>
            <param name="pDeviceID">Caller-supplied pointer to a NULL-terminated string that represents a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the function retrieves device interfaces that are supported by the device for the specified class. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves all interfaces that belong to the specified class.</param>
            <param name="Buffer">Caller-supplied pointer to a buffer that receives multiple, NULL-terminated Unicode strings, each representing the symbolic link name of an interface instance.</param>
            <param name="BufferLen">Caller-supplied value that specifies the length, in characters, of the buffer pointed to by <i>Buffer</i>. Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea">CM_Get_Device_Interface_List_Size</a> to determine the required buffer size.</param>
            <param name="ulFlags">Contains one of the following caller-supplied flags:</param>
            <returns>
            <para>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the error codes with the CR_ prefix as defined in <i>Cfgmgr32.h</i>. The following table includes some of the more common error codes that this function might return. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>Between calling <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizea">CM_Get_Device_Interface_List_Size</a> to get the size of the list and calling <b>CM_Get_Device_Interface_List</b> to get the list, a new device interface can be added to the system causing the size returned to no longer be valid.  Callers should be robust to that condition and retry getting the size and the list if <b>CM_Get_Device_Interface_List</b> returns <b>CR_BUFFER_SMALL</b>.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_Interface_List_Size(System.UInt32@,System.Guid@,Windows.Win32.Foundation.PWSTR,Windows.Win32.Devices.DeviceAndDriverInstallation.CM_GET_DEVICE_INTERFACE_LIST_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Get_Device_Interface_List_Size(System.UInt32*,System.Guid*,Windows.Win32.Foundation.PWSTR,Windows.Win32.Devices.DeviceAndDriverInstallation.CM_GET_DEVICE_INTERFACE_LIST_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_Interface_List_Size(System.UInt32*,System.Guid*,Windows.Win32.Foundation.PWSTR,Windows.Win32.Devices.DeviceAndDriverInstallation.CM_GET_DEVICE_INTERFACE_LIST_FLAGS)">
            <summary>The CM_Get_Device_Interface_List_Size function retrieves the buffer size that must be passed to the CM_Get_Device_Interface_List function. (Unicode)</summary>
            <param name="pulLen">
            <para>Caller-supplied pointer to a location that receives the required length, in characters, of a buffer to hold the multiple Unicode strings that will be returned by <b>CM_Get_Device_Interface_List</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="InterfaceClassGuid">
            <para>Supplies a GUID that identifies a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/overview-of-device-interface-classes">device interface class</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="pDeviceID">
            <para>Caller-supplied pointer to a NULL-terminated string that represents a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If specified, the function retrieves the length of symbolic link names for the device interfaces that are supported by the device, for the specified class. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves the length of symbolic link names for all interfaces that belong to the specified class.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="ulFlags">
            <para>Contains one of the following caller-supplied flags: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the operation succeeds, the function returns <b>CR_SUCCESS</b>. Otherwise, it returns one of the error codes with the <b>CR_</b> prefix as defined in Cfgmgr32.h.</para>
            </returns>
            <remarks>
            <para>> [!NOTE] > The cfgmgr32.h header defines CM_Get_Device_Interface_List_Size as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_get_device_interface_list_sizew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_Interface_Property(System.String,Windows.Win32.Devices.Properties.DEVPROPKEY@,Windows.Win32.Devices.Properties.DEVPROPTYPE@,System.Byte*,System.UInt32@,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Get_Device_Interface_Property(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Devices.Properties.DEVPROPKEY*,Windows.Win32.Devices.Properties.DEVPROPTYPE*,System.Byte*,System.UInt32*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Get_Device_Interface_Property(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Devices.Properties.DEVPROPKEY*,Windows.Win32.Devices.Properties.DEVPROPTYPE*,System.Byte*,System.UInt32*,System.UInt32)">
            <summary>The CM_Get_Device_Interface_Property function retrieves a device property that is set for a device interface.</summary>
            <param name="pszDeviceInterface">Pointer to a string that identifies the device interface instance to retrieve the property from.</param>
            <param name="PropertyKey">Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the device interface property key of the device interface property to retrieve.</param>
            <param name="PropertyType">Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed variable that receives the property-data-type identifier of the requested device interface property. The property-data-type identifier is a bitwise OR between a base-data-type identifier and, if the base-data type is modified, a property-data-type modifier.</param>
            <param name="PropertyBuffer">A pointer to a buffer that receives the requested device interface property. <b>CM_Get_Device_Interface_Property</b> retrieves the requested property only if the buffer is large enough to hold all the property value data. The pointer can be NULL.</param>
            <param name="PropertyBufferSize">The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>*PropertyBufferSize</i> must be set to zero. As output, if the buffer is not large enough to hold all the property value data, <b>CM_Get_Device_Interface_Property</b> returns the size of the data, in bytes, in <i>*PropertyBufferSize</i>.</param>
            <param name="ulFlags">Reserved. Must be set to zero.</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks><b>CM_Get_Device_Interface_Property</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Locate_DevNode(System.UInt32@,Windows.Win32.Foundation.PWSTR,Windows.Win32.Devices.DeviceAndDriverInstallation.CM_LOCATE_DEVNODE_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Locate_DevNode(System.UInt32*,Windows.Win32.Foundation.PWSTR,Windows.Win32.Devices.DeviceAndDriverInstallation.CM_LOCATE_DEVNODE_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Locate_DevNode(System.UInt32*,Windows.Win32.Foundation.PWSTR,Windows.Win32.Devices.DeviceAndDriverInstallation.CM_LOCATE_DEVNODE_FLAGS)">
            <summary>The CM_Locate_DevNode function obtains a device instance handle to the device node that is associated with a specified device instance ID on the local machine. (Unicode)</summary>
            <param name="pdnDevInst">A pointer to a device instance handle that <b>CM_Locate_DevNode</b> retrieves. The retrieved handle is bound to the local machine.</param>
            <param name="pDeviceID">A pointer to a NULL-terminated string representing a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If this value is <b>NULL</b>, or if it points to a zero-length string, the function retrieves a device instance handle to the device at the root of the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/device-tree">device tree</a>.</param>
            <param name="ulFlags">A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:</param>
            <returns>If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_<i>Xxx</i> error codes that are defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks>
            <para>For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.</para>
            <para>> [!NOTE] > The cfgmgr32.h header defines CM_Locate_DevNode as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnodew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Locate_DevNode_Ex(System.UInt32@,Windows.Win32.Foundation.PWSTR,System.UInt32,System.IntPtr)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Locate_DevNode_Ex(System.UInt32*,Windows.Win32.Foundation.PWSTR,System.UInt32,System.IntPtr)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Locate_DevNode_Ex(System.UInt32*,Windows.Win32.Foundation.PWSTR,System.UInt32,System.IntPtr)">
            <summary>The CM_Locate_DevNode_Ex function obtains a device instance handle to the device node that is associated with a specified device instance ID, on a local machine or a remote machine. (Unicode)</summary>
            <param name="pdnDevInst">A pointer to the device instance handle that this function retrieves. The retrieved handle is bound to the machine handle specified by <i>hMachine</i>.</param>
            <param name="pDeviceID">A pointer to a NULL-terminated string representing a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-instance-ids">device instance ID</a>. If this value is <b>NULL</b>, or if it points to a zero-length string, the function supplies a device instance handle to the device at the root of the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/device-tree">device tree</a>.</param>
            <param name="ulFlags">A variable of ULONG type that supplies one of the following flag values that apply if the caller supplies a device instance identifier:</param>
            <param name="hMachine">
            <para>A machine handle obtained from a call to <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_connect_machinew">CM_Connect_Machine</a>, or a machine handle to which a device information set is bound. The machine handle for a device information set is obtained from the <b>RemoteMachineHandle</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinfo_list_detail_data_a">SP_DEVINFO_LIST_DETAIL_DATA</a> structure for the device information set. Call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceinfolistdetaila">SetupDiGetDeviceInfoListDetail</a> to obtain an SP_DEVINFO_LIST_DETAIL_DATA structure. <div class="alert"><b>Note</b>  Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnode_exw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>If the operation succeeds, <b>CM_Locate_DevNode</b> returns CR_SUCCESS. Otherwise, the function returns one of the CR_-prefixed error codes that are defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks>
            <para>For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>. Functionality to access remote machines has been removed in Windows 8 and Windows Server 2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_locate_devnode_exw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Query_And_Remove_SubTree(System.UInt32,Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE*,System.Span{System.Char},System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Query_And_Remove_SubTree(System.UInt32,Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE*,Windows.Win32.Foundation.PWSTR,System.UInt32,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Query_And_Remove_SubTree(System.UInt32,Windows.Win32.Devices.DeviceAndDriverInstallation.PNP_VETO_TYPE*,Windows.Win32.Foundation.PWSTR,System.UInt32,System.UInt32)">
            <summary>The CM_Query_And_Remove_SubTree function checks whether a device instance and its children can be removed and, if so, it removes them. (Unicode)</summary>
            <param name="dnAncestor">Caller-supplied device instance handle to the device at the root of the subtree to be removed. This device instance handle is bound to the local machine.</param>
            <param name="pVetoType">(<i>Optional</i>)  If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>-typed value that indicates the reason for the veto.</param>
            <param name="pszVetoName">(<i>Optional</i>) If the caller does not pass <b>NULL</b> and the removal request is vetoed (that is, the function returns CR_REMOVE_VETOED), on return this points to a text string that is associated with the veto type. The type of information this string provides is dependent on the value received by <i>pVetoType</i>. For information about these strings, see <a href="https://docs.microsoft.com/windows/desktop/api/cfg/ne-cfg-pnp_veto_type">PNP_VETO_TYPE</a>.</param>
            <param name="ulNameLength">Caller-supplied value representing the length (number of characters) of the string buffer supplied by <i>pszVetoName</i>. This should be set to MAX_PATH.</param>
            <param name="ulFlags">A bitwise OR of the caller-supplied flag constants that are described in the <b>Remarks</b> section.</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the other CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks>
            <para>The purpose of the <b>CM_Query_And_Remove_SubTree</b> function is to allow an application to prepare a device for safe removal from the local machine. Use this function to remove devices only if a driver has not set the <b>SurpriseRemovalOK</b> member of <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_device_capabilities">DEVICE_CAPABILITIES</a>. If a driver has set <b>SurpriseRemovalOK</b>, the application should call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_request_device_ejectw">CM_Request_Device_Eject</a> instead of <b>CM_Query_And_Remove_SubTree</b>. <b>CM_Query_And_Remove_SubTree</b> supports setting the flags parameter <i>ulFlags</i> with one of the following two flags; these flags apply only if Windows or an installer vetoes the removal of a device: | Flag | Description | |------|-------------| | CM_REMOVE_UI_OK | The function allows a user dialog box to be displayed to indicate the reason for the veto. This is the default flag setting. | | CM_REMOVE_UI_NOT_OK | The function suppresses the display of a user dialog box that indicates the reason for the veto. | Beginning with Windows XP, <b>CM_Query_And_Remove_SubTree</b> also supports setting the following additional flag; this flag applies only if the function successfully removes the device instance:</para>
            <para>| Flag | Description | |------|-------------| | CM_REMOVE_NO_RESTART | If this flag is set, the function configures the device status such that the device cannot be restarted until after the device status is reset. | The device status is reset by the one of the following: - Calling [CM_Setup_DevNode](nf-cfgmgr32-cm_setup_devnode.md) for the device and specifying CM_SETUP_DEVNODE_RESET. After the device status is reset in this manner, the device can be restarted by calling [CM_Reenumerate_DevNode](nf-cfgmgr32-cm_reenumerate_devnode.md) for the device instance. After resetting the device status, any other operation that enumerates the device will also restart the device, for example, if the Device Manager is used to reenumerate devices. - The device is detached and reattached, or the computer is restarted. In this case, the device status will be reset and the device will be restarted. - If this flag is not set, the device status does not have to be reset. You can restart the removed device by a calling <b>CM_Setup_DevNode</b> for the device and by specifying CM_SETUP_DEVNODE_READY. Any other operation that reenumerates the device will also restart the device. An example of an operation that reenumerates a device is calling <b>CM_Reenumerate_DevNode</b> for the device, detaching and reattaching the device, or restarting the computer. |</para>
            <para>Windows applications that do not require the low-level operation <b>CM_Query_And_Remove_SubTree</b> should use the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-propertychange">DIF_PROPERTYCHANGE</a> request to disable a device instead of using <b>CM_Query_And_Remove_SubTree</b> to remove a device. The DIF_PROPERTYCHANGE request can be used to enable, disable, restart, stop, or change the properties of a device. Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.) For information about using device instance handles that are bound to the local machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child">CM_Get_Child</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_query_and_remove_subtreew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Reenumerate_DevNode_Ex(System.UInt32,System.UInt32,System.IntPtr)">
            <summary>The CM_Reenumerate_DevNode_Ex function enumerates the devices identified by a specified device node and all of its children.</summary>
            <param name="dnDevInst">Caller-supplied device instance handle that is bound to the machine handle supplied by <i>hMachine</i>.</param>
            <param name="ulFlags">Caller-supplied flags that specify how reenumeration should occur. This parameter can be set to a combination of the following flags, as noted:</param>
            <param name="hMachine">
            <para>Caller-supplied machine handle to which the caller-supplied device instance handle is bound. <div class="alert"><b>Note</b>  Using this function to access remote machines is not supported beginning with Windows 8 and Windows Server 2012, as this functionality has been removed.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_reenumerate_devnode_ex#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks>
            <para>If the specified device node represents a hardware or software bus device, the PnP manager queries the device's drivers for a list of children, then attempts to configure and start any child devices that were not previously configured. The PnP manager also initiates surprise-removal of devices that are no longer present (see <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-surprise-removal">IRP_MN_SURPRISE_REMOVAL</a>). Callers of this function must have <b>SeLoadDriverPrivilege</b>. (Privileges are described in the Microsoft Windows SDK documentation.) For information about using device instance handles that are bound to a local or a remote machine, see <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_child_ex">CM_Get_Child_Ex</a>. Functionality to access remote machines has been removed in Windows 8 and Windows Server 2012 and later operating systems thus you cannot access remote machines when running on these versions of Windows.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_reenumerate_devnode_ex#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Set_DevNode_Property(System.UInt32,Windows.Win32.Devices.Properties.DEVPROPKEY@,Windows.Win32.Devices.Properties.DEVPROPTYPE,System.ReadOnlySpan{System.Byte},System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CM_Set_DevNode_Property(System.UInt32,Windows.Win32.Devices.Properties.DEVPROPKEY*,Windows.Win32.Devices.Properties.DEVPROPTYPE,System.Byte*,System.UInt32,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Set_DevNode_Property(System.UInt32,Windows.Win32.Devices.Properties.DEVPROPKEY*,Windows.Win32.Devices.Properties.DEVPROPTYPE,System.Byte*,System.UInt32,System.UInt32)">
            <summary>The CM_Set_DevNode_Property function sets a device instance property.</summary>
            <param name="dnDevInst">Device instance handle that is bound to the local machine.</param>
            <param name="PropertyKey">Pointer to a <a href="https://docs.microsoft.com/windows-hardware/drivers/install/devpropkey">DEVPROPKEY</a> structure that represents the property key of the device instance property to set.</param>
            <param name="PropertyType">A <a href="https://docs.microsoft.com/windows-hardware/drivers/install/property-data-type-identifiers">DEVPROPTYPE</a>-typed value that represents the property-data-type identifier for the device instance property. To delete a property, this must be set to DEVPROP_TYPE_EMPTY.</param>
            <param name="PropertyBuffer">Pointer to a buffer that contains the property value of the device instance property. If either the property or the data is being deleted, this pointer must be set to NULL, and <i>PropertyBufferSize</i> must be set to zero.</param>
            <param name="PropertyBufferSize">The size, in bytes, of the <i>PropertyBuffer</i> buffer. If <i>PropertyBuffer</i> is set to NULL, <i>PropertyBufferSize</i> must be set to zero.</param>
            <param name="ulFlags">Reserved. Must be set to zero.</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks><b>CM_Set_DevNode_Property</b> is part of the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/unified-device-property-model--windows-vista-and-later-">Unified Device Property Model</a>.</remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CM_Setup_DevNode(System.UInt32,System.UInt32)">
            <summary>The CM_Setup_DevNode function restarts a device instance that is not running because there is a problem with the device configuration.</summary>
            <param name="dnDevInst">A device instance handle that is bound to the local system.</param>
            <param name="ulFlags">One of the following flag values:</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise it returns one of the error codes with "CR_" prefix that are defined in <i>Cfgmgr32.h</i>.</returns>
            <remarks>
            <para><a href="https://docs.microsoft.com/windows-hardware/drivers/">Device installation applications</a> should use the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/dif-propertychange">DIF_PROPERTYCHANGE</a> request to restart a device instead of using this function. The DIF_PROPERTYCHANGE request can be used to enable, disable, restart, stop, or change the properties of a device. If a device instance does not have a problem and is already started, <b>CM_Setup_DevNode</b> returns without changing the status of the device instance. Call <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status">CM_Get_DevNode_Status</a> or <a href="https://docs.microsoft.com/windows/desktop/api/cfgmgr32/nf-cfgmgr32-cm_get_devnode_status_ex">CM_Get_DevNode_Status_Ex</a> to determine the status and problem code for a device instance.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/cfgmgr32/nf-cfgmgr32-cm_setup_devnode#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.DBT_DEVICEARRIVAL">
            <summary>The system broadcasts the DBT\_DEVICEARRIVAL device event when a device or piece of media has been inserted and becomes available.</summary>
            <returns>Return **TRUE**.</returns>
            <remarks>If media is being inserted, the type of device arriving is a volume (the **dbch\_devicetype** member is DBT\_DEVTYP\_VOLUME) and the change effects the media (the **dbcv\_flags** member is DBTF\_MEDIA).</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.DBT_DEVICEREMOVECOMPLETE">
            <summary>The system broadcasts the DBT\_DEVICEREMOVECOMPLETE device event when a device or piece of media has been physically removed.</summary>
            <returns>Return **TRUE**.</returns>
            <remarks>
            <para>The system may broadcast a DBT\_DEVICEREMOVECOMPLETE message without sending corresponding [DBT\_DEVICEQUERYREMOVE](dbt-devicequeryremove.md) and [DBT\_DEVICEREMOVEPENDING](dbt-deviceremovepending.md) messages. In such cases, the applications and drivers must recover from the loss of the device as best they can. If media is being removed, the type of device arriving is a volume (the **dbch\_devicetype** member is DBT\_DEVTYP\_VOLUME) and the change effects the media (the **dbcv\_flags** member is DBTF\_MEDIA).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/DevIO/dbt-deviceremovecomplete#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_CREATE">
            <summary>Sent when an application requests that a window be created by calling the CreateWindowEx or CreateWindow function.</summary>
            <returns>
            <para>Type: **LRESULT** If an application processes this message, it should return zero to continue creation of the window. If the application returns –1, the window is destroyed and the [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) or [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) function returns a **NULL** handle.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-create">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_DEVICECHANGE">
            <summary>Notifies an application of a change to the hardware configuration of a device or the computer.</summary>
            <returns>
            <para>Return **TRUE** to grant the request. Return **BROADCAST\_QUERY\_DENY** to deny the request.</para>
            </returns>
            <remarks>For devices that offer software-controllable features, such as ejection and locking, the system typically sends a [DBT\_DEVICEREMOVEPENDING](dbt-deviceremovepending.md) message to let applications and device drivers end their use of the device gracefully. If the system forcibly removes a device, it may not send a [DBT\_DEVICEQUERYREMOVE](dbt-devicequeryremove.md) message before doing so.</remarks>
        </member>
        <member name="F:Windows.Win32.PInvoke.WM_QUIT">
            <summary>Indicates a request to terminate an application, and is generated when the application calls the PostQuitMessage function. This message causes the GetMessage function to return zero.</summary>
            <returns>
            <para>Type: **LRESULT** This message does not have a return value because it causes the message loop to terminate before the message is sent to the application's window procedure.</para>
            </returns>
            <remarks>
            <para>The **WM\_QUIT** message is not associated with a window and therefore will never be received through a window's window procedure. It is retrieved only by the [**GetMessage**](/windows/win32/api/winuser/nf-winuser-getmessage) or [**PeekMessage**](/windows/win32/api/winuser/nf-winuser-peekmessagea) functions. Do not post the **WM\_QUIT** message using the [**PostMessage**](/windows/win32/api/winuser/nf-winuser-postmessagea) function; use [**PostQuitMessage**](/windows/win32/api/winuser/nf-winuser-postquitmessage).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/winmsg/wm-quit#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DeleteObject(Windows.Win32.Graphics.Gdi.HGDIOBJ)">
            <summary>The DeleteObject function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid.</summary>
            <param name="ho">A handle to a logical pen, brush, font, bitmap, region, or palette.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the specified handle is not valid or is currently selected into a DC, the return value is zero.</para>
            </returns>
            <remarks>
            <para>Do not delete a drawing object (pen or brush) while it is still selected into a DC. When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-deleteobject#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.HidD_GetHidGuid(System.Guid@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.HidD_GetHidGuid(System.Guid*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CloseHandle(Windows.Win32.Foundation.HANDLE)">
            <summary>Closes an open object handle.</summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
            </returns>
            <remarks>
            <para>The <b>CloseHandle</b> function closes handles to the following objects: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/handleapi/nf-handleapi-closehandle#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateFile(System.String,System.UInt32,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,System.Nullable{Windows.Win32.Security.SECURITY_ATTRIBUTES},Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES,System.Runtime.InteropServices.SafeHandle)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CreateFile(Windows.Win32.Foundation.PCWSTR,System.UInt32,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,Windows.Win32.Security.SECURITY_ATTRIBUTES*,Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES,Windows.Win32.Foundation.HANDLE)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateFile(Windows.Win32.Foundation.PCWSTR,System.UInt32,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,Windows.Win32.Security.SECURITY_ATTRIBUTES*,Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES,Windows.Win32.Foundation.HANDLE)">
            <summary>Creates or opens a file or I/O device. The most commonly used I/O devices are as follows:\_file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. (Unicode)</summary>
            <param name="lpFileName">
            <para>The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\\) in this name. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, use this Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>. For information on special device names, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>. To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>. <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwDesiredAccess">
            <para>The requested access to the file or device, which can be summarized as read, write, both or neither zero). The most commonly used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>. If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would have been denied. You cannot request an access mode that conflicts with the sharing mode that is specified by the <i>dwShareMode</i> parameter in an open request that already has an open handle. For more information, see the Remarks section of this topic and <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwShareMode">
            <para>The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag. If this parameter is zero and <b>CreateFile</b> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section. You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <b>CreateFile</b> would fail and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return <b>ERROR_SHARING_VIOLATION</b>. To enable a process to share a file or device while another process has the file or device open, use a</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpSecurityAttributes">
            <para>A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes. This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the handle returned by <b>CreateFile</b> cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor. The <b>lpSecurityDescriptor</b> member of the structure specifies a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> for a file or device. If this member is <b>NULL</b>, the file or device associated with the returned handle is assigned a default security descriptor. <b>CreateFile</b> ignores the <b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues to use the <b>bInheritHandle</b> member. The <b>bInheritHandle</b> member of the structure specifies whether the returned handle can be inherited. For more information, see the Remarks section.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwCreationDisposition">
            <para>An action to take on a file or device that exists or does not exist. For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>. For more information, see the Remarks section.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwFlagsAndAttributes">
            <para>The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value for files. This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override <b>FILE_ATTRIBUTE_NORMAL</b>. This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any <b>FILE_ATTRIBUTE_*</b> values. This parameter can also contain Security Quality of Service (SQOS) information by specifying the <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables. <div class="alert"><b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div> <div> </div> Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that <b>CreateFile</b> can open. For additional information, see the Remarks section of this topic and <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>. For more advanced access to file attributes, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list of all file attributes with their values and descriptions, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hTemplateFile">
            <para>A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file attributes and extended attributes for the file that is being created. This parameter can be <b>NULL</b>. When opening an existing file, <b>CreateFile</b> ignores this parameter. When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For additional information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><b>CreateFile</b> was originally developed specifically for file interaction but has since been expanded and enhanced to include most other types of I/O devices and mechanisms available to Windows developers. This section attempts to cover the varied issues developers may experience when using <b>CreateFile</b> in different contexts and with different I/O types. The text attempts to use the word <i>file</i> only when referring specifically to data stored in an actual file on a file system. However, some uses of <i>file</i> may be referring more generally to an I/O object that supports file-like mechanisms. This liberal use of the term <i>file</i> is particularly prevalent in constant names and parameter names because of the previously mentioned historical reasons. When an application is finished using the object handle returned by <b>CreateFile</b>, use the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function to close the handle. This not only frees up system resources, but can have wider influence on things like sharing the file or device and committing data to disk. Specifics are noted within this topic as appropriate. <b>Windows Server 2003 and Windows XP:  </b>A sharing violation occurs if an attempt is made to open a file or directory for deletion on a remote computer when the value of the <i>dwDesiredAccess</i> parameter is the <b>DELETE</b> access flag (0x00010000) <b>OR</b>'ed with any other access flag, and the remote file or directory has not been opened with <b>FILE_SHARE_DELETE</b>. To avoid the sharing violation in this scenario, open the remote file or directory with the <b>DELETE</b> access right only, or call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> without first opening the file or directory for deletion. Some file systems, such as the NTFS file system, support compression or encryption for individual files and directories. On volumes that have a mounted file system with this support, a new file inherits the compression and encryption attributes of its directory. You cannot use <b>CreateFile</b> to control compression, decompression, or decryption on a file or directory. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>, <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</a>, and <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>. <b>Windows Server 2003 and Windows XP:  </b>For backward compatibility purposes, <b>CreateFile</b> does not apply inheritance rules when you specify a security descriptor in <i>lpSecurityAttributes</i>. To support inheritance, functions that later query the security descriptor of this file may heuristically determine and report that inheritance is in effect. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>. As stated previously, if the <i>lpSecurityAttributes</i> parameter is <b>NULL</b>, the handle returned by <b>CreateFile</b> cannot be inherited by any child processes your application may create. The following information regarding this parameter also applies: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.FreeLibrary(Windows.Win32.Foundation.HMODULE)">
            <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
            <param name="hLibModule">
            <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
            </returns>
            <remarks>
            <para>The system maintains a per-process reference count for each loaded module. A  module that was loaded at process initialization due to load-time dynamic linking has a reference count of one. The reference count for a module is incremented each time the  module is loaded by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>. The reference count is also incremented by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> unless the  module  is being loaded for the first time and is being loaded as   a data or image file. The reference count is decremented each time the <b>FreeLibrary</b> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function is called for the module. When a  module's reference count reaches zero or the process terminates, the system unloads the module from the address space of the  process. Before unloading a library module, the system enables the module to detach from the process by calling the module's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function, if it has one, with the DLL_PROCESS_DETACH value. Doing so gives the library module an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process. It is not safe to call <b>FreeLibrary</b> from <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. Calling <b>FreeLibrary</b> does not affect other processes that are using the same module. Use caution when calling <b>FreeLibrary</b> with a handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. The <b>GetModuleHandle</b> function does not increment a module's reference count, so passing this handle to <b>FreeLibrary</b> can cause a module to be unloaded prematurely. A thread that must unload the DLL in which it is executing and then terminate itself should call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> instead of calling <b>FreeLibrary</b> and <b>ExitThread</b> separately. Otherwise, a race condition can occur. For details, see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DeviceIoControl(System.Runtime.InteropServices.SafeHandle,System.UInt32,System.Void*,System.UInt32,System.Void*,System.UInt32,System.UInt32*,System.Threading.NativeOverlapped*)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.DeviceIoControl(Windows.Win32.Foundation.HANDLE,System.UInt32,System.Void*,System.UInt32,System.Void*,System.UInt32,System.UInt32*,System.Threading.NativeOverlapped*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.DeviceIoControl(Windows.Win32.Foundation.HANDLE,System.UInt32,System.Void*,System.UInt32,System.Void*,System.UInt32,System.UInt32*,System.Threading.NativeOverlapped*)">
            <summary>Sends a control code directly to a specified device driver, causing the corresponding device to perform the corresponding operation.</summary>
            <param name="hDevice">
            <para>A handle to the device on which the operation is to be performed. The device is typically a volume, directory, file, or stream. To retrieve a device handle, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function. For more information, see Remarks.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwIoControlCode">
            <para>The control code for the operation. This value identifies the specific operation to be performed and the type of device on which to perform it. For a list of the control codes, see Remarks. The documentation for each control code provides usage details for the <i>lpInBuffer</i>, <i>nInBufferSize</i>, <i>lpOutBuffer</i>, and <i>nOutBufferSize</i> parameters.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpInBuffer">
            <para>A pointer to the input buffer that contains the data required to perform the operation. The format of this data depends on the value of the <i>dwIoControlCode</i> parameter. This parameter can be <b>NULL</b> if <i>dwIoControlCode</i> specifies an operation that does not require input data.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nInBufferSize">The size of the input buffer, in bytes.</param>
            <param name="lpOutBuffer">
            <para>A pointer to the output buffer that is to receive the data returned by the operation. The format of this data depends on the value of the <i>dwIoControlCode</i> parameter. This parameter can be <b>NULL</b> if <i>dwIoControlCode</i> specifies an operation that does not return data.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nOutBufferSize">The size of the output buffer, in bytes.</param>
            <param name="lpBytesReturned">
            <para>A pointer to a variable that receives the size of the data stored in the output buffer, in bytes. If the output buffer is too small to receive any data,  the call fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INSUFFICIENT_BUFFER</b>, and <i>lpBytesReturned</i> is zero. If the output buffer is too small to hold all of the data but can hold some entries, some drivers will return as much data as fits. In this case, the call fails, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_MORE_DATA</b>, and <i>lpBytesReturned</i> indicates the amount of data received. Your application should call <b>DeviceIoControl</b> again with the same operation, specifying a new starting point. If <i>lpOverlapped</i> is <b>NULL</b>, <i>lpBytesReturned</i> cannot be <b>NULL</b>. Even when an operation returns no output data and <i>lpOutBuffer</i> is <b>NULL</b>, <b>DeviceIoControl</b> makes use of <i>lpBytesReturned</i>. After such an operation, the value of <i>lpBytesReturned</i> is meaningless. If <i>lpOverlapped</i> is not <b>NULL</b>, <i>lpBytesReturned</i> can be <b>NULL</b>. If this parameter is not <b>NULL</b> and the operation returns data, <i>lpBytesReturned</i> is meaningless until the overlapped operation has completed. To retrieve the number of bytes returned, call <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>. If <i>hDevice</i> is associated with an I/O completion port, you can retrieve the number of bytes returned by calling <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpOverlapped">
            <para>A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. If <i>hDevice</i> was opened without specifying <b>FILE_FLAG_OVERLAPPED</b>, <i>lpOverlapped</i> is ignored. If <i>hDevice</i> was opened with the <b>FILE_FLAG_OVERLAPPED</b> flag, the operation is performed as an overlapped (asynchronous) operation. In this case, <i>lpOverlapped</i> must point to a valid <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that contains a handle to an event object. Otherwise, the function fails in unpredictable ways. For overlapped operations, <b>DeviceIoControl</b> returns immediately, and the event object is signaled when the operation has been completed. Otherwise, the function does not return until the operation has been completed or an error occurs.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the operation completes successfully, the return value is nonzero (TRUE). If the operation fails or is pending, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>To retrieve a handle to the device, you must call the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with either the name of a device or the name of the driver associated with a device. To specify a device name, use the following format: \\\\.&#92;<i>DeviceName</i> <b>DeviceIoControl</b> can accept a handle to a specific device. For example, to open a handle to the logical drive A: with <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>, specify \\\\.\a:. Alternatively, you can use the names \\\\.\PhysicalDrive0, \\\\.\PhysicalDrive1, and so on, to open handles to the physical drives on a system. You should specify the <b>FILE_SHARE_READ</b> and <b>FILE_SHARE_WRITE</b> access flags when calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> to open a handle to a device driver. However, when you open a communications resource, such as a serial port, you must specify exclusive access. Use the other <b>CreateFile</b> parameters as follows when opening a device handle: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.FormatMessage(Windows.Win32.System.Diagnostics.Debug.FORMAT_MESSAGE_OPTIONS,System.Void*,System.UInt32,System.UInt32,System.Span{System.Char},System.UInt32,System.SByte**)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.FormatMessage(Windows.Win32.System.Diagnostics.Debug.FORMAT_MESSAGE_OPTIONS,System.Void*,System.UInt32,System.UInt32,Windows.Win32.Foundation.PWSTR,System.UInt32,System.SByte**)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.FormatMessage(Windows.Win32.System.Diagnostics.Debug.FORMAT_MESSAGE_OPTIONS,System.Void*,System.UInt32,System.UInt32,Windows.Win32.Foundation.PWSTR,System.UInt32,System.SByte**)">
            <summary>The FormatMessageW (Unicode) function (winbase.h) formats a message string.</summary>
            <param name="dwFlags">
            <para>The formatting options, and how to interpret the <i>lpSource</i> parameter. The low-order byte of <i>dwFlags</i> specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpSource">
            <para>The location of the message definition. The type of this parameter depends upon the settings in the <i>dwFlags</i> parameter. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwMessageId">
            <para>The message identifier for the requested message. This parameter is ignored if <i>dwFlags</i> includes <b>FORMAT_MESSAGE_FROM_STRING</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwLanguageId">
            <para>The <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">language identifier</a> for the requested message. This parameter is ignored if <i>dwFlags</i> includes <b>FORMAT_MESSAGE_FROM_STRING</b>. If you pass a specific <b>LANGID</b> in this parameter, <b>FormatMessage</b> will return a message for that <b>LANGID</b> only. If the function cannot find a message for that <b>LANGID</b>, it sets Last-Error to <b>ERROR_RESOURCE_LANG_NOT_FOUND</b>. If you pass in zero, <b>FormatMessage</b> looks for a message for <b>LANGIDs</b> in the following order: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpBuffer">
            <para>A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If <i>dwFlags</i> includes <b>FORMAT_MESSAGE_ALLOCATE_BUFFER</b>, the function allocates a buffer using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> function, and places the pointer to the buffer at the address specified in <i>lpBuffer</i>. This buffer cannot be larger than 64K bytes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nSize">
            <para>If the <b>FORMAT_MESSAGE_ALLOCATE_BUFFER</b> flag is not set, this parameter specifies the size of the output buffer, in <b>TCHARs</b>. If <b>FORMAT_MESSAGE_ALLOCATE_BUFFER</b> is set, this parameter specifies the minimum number of <b>TCHARs</b> to allocate for an output buffer. The output buffer cannot be larger than 64K bytes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Arguments">
            <para>An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the <i>Arguments</i> array; a %2 indicates the second argument; and so on. The interpretation of each value depends on the formatting information associated with the insert in the message definition. The default is to treat each value as a pointer to a null-terminated string. By default, the <i>Arguments</i> parameter is of type <b>va_list*</b>, which is a language- and implementation-specific data type for describing a variable number of arguments. The state of the <b>va_list</b> argument is undefined upon return from the function. To use the <b>va_list</b> again, destroy the variable argument list pointer using <b>va_end</b> and reinitialize it with <b>va_start</b>. If you do not have a pointer of type <b>va_list*</b>, then specify the <b>FORMAT_MESSAGE_ARGUMENT_ARRAY</b> flag and pass a pointer to an array of <b>DWORD_PTR</b> values; those values are input to the message formatted as the insert values. Each insert must have a corresponding element in the array.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-formatmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is the number of <b>TCHARs</b> stored in the output buffer, excluding the terminating null character. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Within the message text, several escape sequences are supported for dynamically formatting the message. These escape sequences and their meanings are shown in the following tables. All escape sequences start with the percent character (%). </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-formatmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetModuleHandle(System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetModuleHandle(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetModuleHandle(Windows.Win32.Foundation.PCWSTR)">
            <summary>Retrieves a module handle for the specified module. The module must have been loaded by the calling process. (Unicode)</summary>
            <param name="lpModuleName">
            <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
            <para>If this parameter is NULL, <b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file). The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the specified module. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process. If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com/windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> to specify a memory location rather than a DLL name. The <b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the <b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely. This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetOverlappedResult(System.Runtime.InteropServices.SafeHandle,System.Threading.NativeOverlapped@,System.UInt32@,Windows.Win32.Foundation.BOOL)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetOverlappedResult(Windows.Win32.Foundation.HANDLE,System.Threading.NativeOverlapped*,System.UInt32*,Windows.Win32.Foundation.BOOL)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetOverlappedResult(Windows.Win32.Foundation.HANDLE,System.Threading.NativeOverlapped*,System.UInt32*,Windows.Win32.Foundation.BOOL)">
            <summary>Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device.</summary>
            <param name="hFile">
            <para>A handle to the file, named pipe, or communications device. This is the same handle that was specified when the overlapped operation was started by a call to any of the following functions: - [ReadFile](../fileapi/nf-fileapi-readfile.md) - [WriteFile](../fileapi/nf-fileapi-writefile.md) - [ConnectNamedPipe](../namedpipeapi/nf-namedpipeapi-connectnamedpipe.md) - [TransactNamedPipe](../namedpipeapi/nf-namedpipeapi-transactnamedpipe.md) - [DeviceIoControl](./nf-ioapiset-deviceiocontrol.md) - [WaitCommEvent](../winbase/nf-winbase-waitcommevent.md) - [ReadDirectoryChangesW](../winbase/nf-winbase-readdirectorychangesw.md) - [LockFileEx](../fileapi/nf-fileapi-lockfileex.md) - [ReadDirectoryChangesW](../winbase/nf-winbase-readdirectorychangesw.md)</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpOverlapped">
            <para>A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that was specified when the overlapped operation was started.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpNumberOfBytesTransferred">
            <para>A pointer to a variable that receives the number of bytes that were actually transferred by a read or write operation. For a <a href="https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe">TransactNamedPipe</a> operation, this is the number of bytes that were read from the pipe. For a <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> operation, this is the number of bytes of output data returned by the device driver. For a <a href="https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe">ConnectNamedPipe</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-waitcommevent">WaitCommEvent</a> operation, this value is undefined.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="bWait">
            <para>If this parameter is <b>TRUE</b>, and the <b>Internal</b> member of the <i>lpOverlapped</i> structure is <b>STATUS_PENDING</b>, the function does not return until the operation has been completed. If this parameter is <b>FALSE</b> and the operation is still pending, the function returns <b>FALSE</b> and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_IO_INCOMPLETE</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The results reported by the <b>GetOverlappedResult</b> function are those of the specified handle's last overlapped operation to which the specified <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure was provided, and for which the operation's results were pending. A pending operation is indicated when the function that started the operation returns <b>FALSE</b>, and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns <b>ERROR_IO_PENDING</b>. When an I/O operation is pending, the function that started the operation resets the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure to the nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled state. If the <i>bWait</i> parameter is <b>TRUE</b>, <b>GetOverlappedResult</b> determines whether the pending operation has been completed by waiting for the event object to be in the signaled state. If the <b>hEvent</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is <b>NULL</b>, the system uses the state of the <i>hFile</i> handle to signal when the operation has been completed. Use of file, named pipe, or communications-device handles for this purpose is discouraged. It is safer to use an event object because of the confusion that can occur when multiple simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this situation, there is no way to know which operation caused the object's state to be signaled.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetProcAddress(System.Runtime.InteropServices.SafeHandle,System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetProcAddress(Windows.Win32.Foundation.HMODULE,Windows.Win32.Foundation.PCSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetProcAddress(Windows.Win32.Foundation.HMODULE,Windows.Win32.Foundation.PCSTR)">
            <summary>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</summary>
            <param name="hModule">
            <para>A handle to the DLL module that contains the function or variable. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-loadpackagedlibrary">LoadPackagedLibrary</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function returns this handle. The <b>GetProcAddress</b> function does not retrieve addresses from modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>
            <para>If the function succeeds, the return value is the address of the exported function or variable. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The spelling and case of a function name pointed to by <i>lpProcName</i> must be identical to that in the <b>EXPORTS</b> statement of the source DLL's module-definition (.def) file. The exported names of functions may differ from the names you use when calling these functions in your code. This difference is hidden by macros used in the SDK header files. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. The <i>lpProcName</i> parameter can identify the DLL function by specifying an ordinal value associated with the function in the <b>EXPORTS</b> statement. <b>GetProcAddress</b> verifies that the specified ordinal is in the range 1 through the highest ordinal value exported in the .def file. The function then uses the ordinal as an index to read the function's address from a function table. If the .def file does not number the functions consecutively from 1 to <i>N</i> (where <i>N</i> is the number of exported functions), an error can occur where <b>GetProcAddress</b> returns an invalid, non-NULL address, even though there is no function with the specified ordinal. If the function might not exist in the DLL module—for example, if the function  is available only on Windows Vista but the application  might be running on Windows XP—specify the function by name rather than by ordinal value and design your application to handle the case when the function is not available, as shown in the following code fragment.</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadLibrary(System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.LoadLibrary(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.LoadLibrary(Windows.Win32.Foundation.PCWSTR)">
            <summary>Loads the specified module into the address space of the calling process. (LoadLibraryW)</summary>
            <param name="lpLibFileName">
            <para>The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file). If the specified module is an executable module, static imports are not loaded; instead, the module is loaded as if by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexw">LoadLibraryEx</a> with the `DONT_RESOLVE_DLL_REFERENCES` flag. The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. If the string specifies a full path, the function searches only that path for the module. If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module; for more information, see the Remarks. If the function cannot find the  module, the function fails. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File or Directory</a>. If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension ".DLL" to the module name. To prevent the function from appending ".DLL" to the module name, include a trailing point character (.) in the module name string.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the module. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>To enable or disable error messages displayed by the loader during DLL loads, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> function. <b>LoadLibrary</b> can be used to load a library module into the address space of the process and return a handle that can be used in <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> to get the address of a DLL function. <b>LoadLibrary</b> can also be used to load other executable modules. For example, the function can specify an .exe file to get a handle that can be used in <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a>. However, do not use <b>LoadLibrary</b> to run an .exe file. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> function. If the specified module is a DLL that is not already loaded for the calling process, the system calls the DLL's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function with the <b>DLL_PROCESS_ATTACH</b> value. If <b>DllMain</b> returns <b>TRUE</b>, <b>LoadLibrary</b> returns a handle to the module. If <b>DllMain</b> returns <b>FALSE</b>, the system unloads the DLL from the process address space and <b>LoadLibrary</b> returns <b>NULL</b>. It is not safe to call <b>LoadLibrary</b> from <b>DllMain</b>. For more information, see the Remarks section in <b>DllMain</b>. Module handles are not global or inheritable. A call to <b>LoadLibrary</b> by one process does not produce a handle that another process can use — for example, in calling <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>. The other process must make its own call to <b>LoadLibrary</b> for the module before calling <b>GetProcAddress</b>. If <i>lpFileName</i> does not include a path and there is more than one loaded module with the same base name and extension, the function returns a handle to the module that was loaded first. If no file name extension is specified in the <i>lpFileName</i> parameter, the default library extension .dll is appended. However, the file name string can include a trailing point character (.) to indicate that the module name has no extension. When no path is specified, the function searches for loaded modules whose base name matches the base name of the module to be loaded. If the name matches, the load succeeds. Otherwise, the function searches for the file. The first directory searched is the directory containing the image file used to create the calling process (for more information, see the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a> function). Doing this allows private dynamic-link library (DLL) files associated with a process to be found without adding the process's installed directory to the PATH environment variable. If a relative path is specified, the entire relative path is appended to every token in the DLL search path list. To load a module from a relative path without searching any other path, use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName</a> to get a nonrelative path and call <b>LoadLibrary</b> with the nonrelative path. For more information on the DLL search order, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/dynamic-link-library-search-order">Dynamic-Link Library Search Order</a>. The search path can be altered using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setdlldirectorya">SetDllDirectory</a> function. This solution is recommended instead of using <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcurrentdirectory">SetCurrentDirectory</a> or hard-coding the full path to the DLL. If a path is specified and there is a redirection file for the application, the function searches for the module in the application's directory. If the module exists in the application's directory, <b>LoadLibrary</b> ignores the specified path and loads the module from the application's directory. If the module does not exist in the application's directory, <b>LoadLibrary</b> loads the module from the specified directory. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/dynamic-link-library-redirection">Dynamic Link Library Redirection</a>. If you call <b>LoadLibrary</b> with the name of an assembly without a path specification and the assembly is listed in the system compatible manifest, the call is automatically redirected to the side-by-side assembly. The system maintains a per-process reference count on all loaded modules. Calling <b>LoadLibrary</b> increments the reference count. Calling the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function decrements the reference count. The system unloads a module when its reference count reaches zero or when the process terminates (regardless of the reference count). <b>Windows Server 2003 and Windows XP:  </b>The Visual C++ compiler supports a syntax that enables you to declare thread-local variables: <b>_declspec(thread)</b>. If you use this syntax in a DLL, you will not be able to load the DLL explicitly using <b>LoadLibrary</b> on versions of Windows prior to Windows Vista. If your DLL will be loaded explicitly, you must use the thread local storage functions instead of <b>_declspec(thread)</b>. For an example, see <a href="https://docs.microsoft.com/windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library">Using Thread Local Storage in a Dynamic Link Library</a>. <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3> Do not use the <a href="https://docs.microsoft.com/windows/desktop/api/processenv/nf-processenv-searchpathw">SearchPath</a> function to retrieve a path to a DLL for a subsequent <b>LoadLibrary</b> call. The <b>SearchPath</b> function uses a different search order than <b>LoadLibrary</b> and it does not use safe process search mode unless this is explicitly enabled by calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setsearchpathmode">SetSearchPathMode</a> with <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b>. Therefore, <b>SearchPath</b> is likely to first search the user’s current working directory for the specified DLL. If an attacker has copied a malicious version of a DLL into the current working directory, the path retrieved by <b>SearchPath</b> will point to the malicious DLL, which <b>LoadLibrary</b> will then load. Do not make assumptions about the operating system version based on a <b>LoadLibrary</b> call that searches for a DLL. If the application is running in an environment where the DLL is legitimately not present but a malicious version of the DLL is in the search path, the malicious version of the DLL may be loaded. Instead, use the recommended techniques described in <a href="https://docs.microsoft.com/windows/desktop/SysInfo/getting-the-system-version">Getting the System Version</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.LocalFree_SafeHandle(Windows.Win32.Foundation.HLOCAL)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.LocalFree(Windows.Win32.Foundation.HLOCAL)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.LocalFree(Windows.Win32.Foundation.HLOCAL)">
            <summary>Frees the specified local memory object and invalidates its handle.</summary>
            <param name="hMem">
            <para>A handle to the local memory object. This handle is returned by either the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localalloc">LocalAlloc</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localrealloc">LocalReAlloc</a> function. It is not safe to free memory allocated with <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globalalloc">GlobalAlloc</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-localfree#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is <b>NULL</b>. If the function fails, the return value is equal to a handle to the local memory object. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If the process tries to examine or modify the memory after it has been freed, heap corruption may occur or an access violation exception (EXCEPTION_ACCESS_VIOLATION) may be generated. If the <i>hMem</i> parameter is <b>NULL</b>, <b>LocalFree</b> ignores the parameter and returns <b>NULL</b>. The <b>LocalFree</b> function will free a locked memory object. A locked memory object has a lock count greater than zero. The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-locallock">LocalLock</a> function locks a local memory object and increments the lock count by one. The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localunlock">LocalUnlock</a> function unlocks it and decrements the lock count by one. To get the lock count of a local memory object, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-localflags">LocalFlags</a> function. If an application is running under a debug version of the system, <b>LocalFree</b> will issue a message that tells you that a locked object is being freed. If you are debugging the application, <b>LocalFree</b> will enter a breakpoint just before freeing a locked object. This allows you to verify the intended behavior, then continue execution.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-localfree#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetLastError(Windows.Win32.Foundation.WIN32_ERROR)">
            <summary>Sets the last-error code for the calling thread.</summary>
            <param name="dwErrCode">The last-error code for the thread.</param>
            <remarks>
            <para>The last-error code is kept in thread local storage so that multiple threads do not overwrite each other's values. Most functions call <b>SetLastError</b> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a> only when they fail. However, some system functions call <b>SetLastError</b> or <b>SetLastErrorEx</b> under conditions of success; those cases are noted in each function's documentation. Applications can optionally retrieve the value set by this function by using the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function immediately after a function fails. Error codes are 32-bit values (bit 31 is the most significant bit). Bit 29 is reserved for application-defined error codes; no system error code has this bit set. If you are defining an error code for your application, set this bit to indicate that the error code has been defined by your application and to ensure that your error code does not conflict with any system-defined error codes.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.UpdateDriverForPlugAndPlayDevices(Windows.Win32.Foundation.HWND,System.String,System.String,Windows.Win32.Devices.DeviceAndDriverInstallation.UPDATEDRIVERFORPLUGANDPLAYDEVICES_FLAGS,Windows.Win32.Foundation.BOOL*)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.UpdateDriverForPlugAndPlayDevices(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Devices.DeviceAndDriverInstallation.UPDATEDRIVERFORPLUGANDPLAYDEVICES_FLAGS,Windows.Win32.Foundation.BOOL*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.UpdateDriverForPlugAndPlayDevices(Windows.Win32.Foundation.HWND,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Devices.DeviceAndDriverInstallation.UPDATEDRIVERFORPLUGANDPLAYDEVICES_FLAGS,Windows.Win32.Foundation.BOOL*)">
            <summary>Given an INF file and a hardware ID, the UpdateDriverForPlugAndPlayDevices function installs updated drivers for devices that match the hardware ID. (Unicode)</summary>
            <param name="hwndParent">A handle to the top-level window to use for any UI related to installing devices.</param>
            <param name="HardwareId">A pointer to a NULL-terminated string that supplies the hardware identifier to match existing devices on the computer. The maximum length of a NULL-terminated hardware identifier is MAX_DEVICE_ID_LEN. For more information about hardware identifiers, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-identification-strings">Device Identification Strings</a>.</param>
            <param name="FullInfPath">A pointer to a NULL-terminated string that supplies the full path file name of an INF file. The files should be on the distribution media or in a vendor-created directory, not in a system location such as <i>%SystemRoot%\inf</i>. <b>UpdateDriverForPlugAndPlayDevices</b> copies driver files to the appropriate system locations if the installation is successful.</param>
            <param name="InstallFlags">A caller-supplied value created by using OR to combine zero or more of the following bit flags:</param>
            <param name="bRebootRequired">
            <para>A pointer to a BOOL-typed variable that indicates whether a restart is required and who should prompt for it. This pointer is optional and can be <b>NULL</b>. If the pointer is <b>NULL</b>, <b>UpdateDriverForPlugAndPlayDevices</b> prompts for a restart after installing drivers, if necessary. If the pointer is supplied, the function returns a BOOLEAN value that is <b>TRUE</b> if the system should be restarted. It is then the caller's responsibility to prompt for a restart. For more information, see the following <b>Remarks</b> section.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-updatedriverforplugandplaydevicesw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>The function returns <b>TRUE</b> if a device was upgraded to the specified driver. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <b>GetLastError</b>. Possible error values returned by <b>GetLastError</b> are included in the following table.</para>
            <para></para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><b>UpdateDriverForPlugAndPlayDevices</b> scans the devices on the system and attempts to install the drivers specified by <i>FullInfPath</i> for any devices that match the specified <i>HardwareId</i> value. The default behavior is to only install the specified drivers if they are better match than the currently installed drivers and the specified drivers are also a better match than any drivers in %<i>SystemRoot</i>%&#92;<i>inf</i>. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/how-setup-selects-drivers">How Windows Selects Drivers</a>. <b>UpdateDriverForPlugAndPlayDevices</b> can also be used to determine whether the device with the specified <i>HardwareId</i> value is plugged in. For more information, see <a href="https://docs.microsoft.com/windows-hardware/drivers/install/writing-a-device-installation-application">Writing a Device Installation Application</a>. <b>UpdateDriverForPlugAndPlayDevices</b> sends an <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-remove-device">IRP_MN_QUERY_REMOVE_DEVICE</a> request to the specified device, all the children of the device, and all other devices that are recursively part of the removal relations for the device. If any of these devices fail a query remove request, <b>UpdateDriverForPlugAndPlayDevices</b> sets the DI_NEEDREBOOT flag in the <b>Flags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/ns-setupapi-sp_devinstall_params_a">SP_DEVINSTALL_PARAMS</a> structure for the device. For information about removal relations, see the <a href="https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-device-relations">IRP_MN_QUERY_DEVICE_RELATIONS</a> request. Generally, <a href="https://docs.microsoft.com/windows-hardware/drivers/">device installation applications</a> should supply <b>NULL</b> for <i>bRebootRequired</i>. So, the system will initiate a restart if necessary. An application should specify a pointer value <i>only</i> in the following cases: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/newdev/nf-newdev-updatedriverforplugandplaydevicesw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetupDiDestroyDeviceInfoList(Windows.Win32.Devices.DeviceAndDriverInstallation.HDEVINFO)">
            <summary>The SetupDiDestroyDeviceInfoList function deletes a device information set and frees all associated memory.</summary>
            <param name="DeviceInfoSet">A handle to the <a href="https://docs.microsoft.com/windows-hardware/drivers/install/device-information-sets">device information set</a> to delete.</param>
            <returns>The function returns <b>TRUE</b> if it is successful. Otherwise, it returns <b>FALSE</b> and the logged error can be retrieved with a call to <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdidestroydeviceinfolist">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetupDiOpenClassRegKey(System.Nullable{System.Guid},System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.SetupDiOpenClassRegKey(System.Guid*,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetupDiOpenClassRegKey(System.Guid*,System.UInt32)">
            <summary>The SetupDiOpenClassRegKey function opens the setup class registry key or a specific class's subkey.</summary>
            <param name="ClassGuid">A pointer to the GUID of the setup class whose key is to be opened. This parameter is optional and can be <b>NULL</b>. If this parameter is <b>NULL</b>, the root of the setup class tree (<b>HKLM\SYSTEM\CurrentControlSet\Control\Class</b>) is opened.</param>
            <param name="samDesired">The registry security access for the key to be opened. For information about registry security access values of type REGSAM, see the Microsoft Windows SDK documentation.</param>
            <returns>
            <para>If the function is successful, it returns a handle to an opened registry key where information about this setup class can be stored/retrieved. If the function fails, it returns INVALID_HANDLE_VALUE. To get extended error information, call <a href="https://docs.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Depending on the value that is passed in the <i>samDesired</i> parameter, it might be necessary for the caller of this function to be a member of the Administrators group. This function does not create a registry key if it does not already exist. The handle returned from this function must be closed by calling <a href="https://docs.microsoft.com/windows/win32/api/winreg/nf-winreg-regclosekey">RegCloseKey</a>. To open the interface class registry key or a specific interface class subkey, call <a href="https://docs.microsoft.com/windows/desktop/api/setupapi/nf-setupapi-setupdiopenclassregkeyexa">SetupDiOpenClassRegKeyEx</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/setupapi/nf-setupapi-setupdiopenclassregkey#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyMenu(Windows.Win32.UI.WindowsAndMessaging.HMENU)">
            <summary>Destroys the specified menu and frees any memory that the menu occupies.</summary>
            <param name="hMenu">
            <para>Type: <b>HMENU</b> A handle to the menu to be destroyed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Before closing, an application must use the <b>DestroyMenu</b> function to destroy a menu not assigned to a window. A menu that is assigned to a window is automatically destroyed when the application closes. <b>DestroyMenu</b> is recursive, that is, it will destroy the menu and all its submenus.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateWindowEx(Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE,System.String,System.String,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.HWND,System.Runtime.InteropServices.SafeHandle,System.Runtime.InteropServices.SafeHandle,System.Void*)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CreateWindowEx(Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.HMENU,Windows.Win32.Foundation.HINSTANCE,System.Void*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateWindowEx(Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.HMENU,Windows.Win32.Foundation.HINSTANCE,System.Void*)">
            <summary>Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function. (Unicode)</summary>
            <param name="dwExStyle">
            <para>Type: <b>DWORD</b> The extended window style of the window being created. For a list of possible values, see  <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Styles</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpClassName">
            <para>Type: <b>LPCTSTR</b> A <b>null</b>-terminated string or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. If <i>lpClassName</i> is a string, it specifies the window class name. The class name can be any name registered with <b>RegisterClass</b> or <b>RegisterClassEx</b>, provided that the module that registers the class is also the module that creates the window. The class name can also be any of the predefined <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">system class</a> names.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpWindowName">
            <para>Type: <b>LPCTSTR</b> The window name. If the window style specifies a title bar, the window title pointed to by <i>lpWindowName</i> is displayed in the title bar. When using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create controls, such as buttons, check boxes, and static controls, use <i>lpWindowName</i> to specify the text of the control. When creating a static control with the <b>SS_ICON</b> style, use <i>lpWindowName</i> to specify the icon name or identifier. To specify an identifier, use the syntax "#<i>num</i>".</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwStyle">
            <para>Type: <b>DWORD</b> The style of the window being created. This parameter can be a combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style values</a>, plus the control styles indicated in the Remarks section.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="X">
            <para>Type: <b>int</b> The initial horizontal position of the window. For an overlapped or pop-up window, the <i>x</i> parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>x</i> is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If <i>x</i> is set to <b>CW_USEDEFAULT</b>, the system selects the default position for the window's upper-left corner and ignores the <i>y</i> parameter. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if it is specified for a pop-up or child window, the <i>x</i> and <i>y</i> parameters are set to zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Y">
            <para>Type: <b>int</b> The initial vertical position of the window. For an overlapped or pop-up window, the <i>y</i> parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>y</i> is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box <i>y</i> is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area.</para>
            <para>If an overlapped window is created with the <b>WS_VISIBLE</b> style bit set and the <i>x</i> parameter is set to <b>CW_USEDEFAULT</b>, then the <i>y</i> parameter determines how the window is shown. If the <i>y</i> parameter is <b>CW_USEDEFAULT</b>, then the window manager calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with the <b>SW_SHOW</b> flag after the window has been created. If the <i>y</i> parameter is some other value, then the window manager calls <b>ShowWindow</b> with that value as the <i>nCmdShow</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nWidth">
            <para>Type: <b>int</b> The width, in device units, of the window. For overlapped windows, <i>nWidth</i> is the window's width, in screen coordinates, or <b>CW_USEDEFAULT</b>. If <i>nWidth</i> is <b>CW_USEDEFAULT</b>, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if <b>CW_USEDEFAULT</b> is specified for a pop-up or child window, the <i>nWidth</i> and <i>nHeight</i> parameter are set to zero.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nHeight">
            <para>Type: <b>int</b> The height, in device units, of the window. For overlapped windows, <i>nHeight</i> is the window's height, in screen coordinates. If the <i>nWidth</i> parameter is set to <b>CW_USEDEFAULT</b>, the system ignores <i>nHeight</i>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hWndParent">
            <para>Type: <b>HWND</b> A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window handle. This parameter is optional for pop-up windows. To create a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>, supply <b>HWND_MESSAGE</b> or a handle to an existing message-only window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hMenu">
            <para>Type: <b>HMENU</b> A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, <i>hMenu</i> identifies the menu to be used with the window; it can be <b>NULL</b> if the class menu is to be used. For a child window, <i>hMenu</i> specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The application determines the child-window identifier; it must be unique for all child windows with the same parent window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hInstance">
            <para>Type: <b>HINSTANCE</b> A handle to the instance of the module to be associated with the window.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpParam">
            <para>Type: <b>LPVOID</b> Pointer to a value to be passed to the window through the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-createstructa">CREATESTRUCT</a> structure (<b>lpCreateParams</b> member) pointed to by the <i>lParam</i> param of the <b>WM_CREATE</b> message.  This message is sent to the created window by this function before it returns. If an application calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create a MDI client window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-clientcreatestruct">CLIENTCREATESTRUCT</a> structure. If an MDI client window calls <b>CreateWindow</b> to create an MDI child window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mdicreatestructa">MDICREATESTRUCT</a> structure. <i>lpParam</i> may be <b>NULL</b> if no additional data is needed.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HWND</b> If the function succeeds, the return value is a handle to the new window. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function typically fails for one of the following reasons: </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The <b>CreateWindowEx</b> function sends <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccreate">WM_NCCREATE</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccalcsize">WM_NCCALCSIZE</a>, and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-create">WM_CREATE</a> messages to the window being created. If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is itself topmost). For information on controlling whether the Taskbar displays a button for the created window, see <a href="https://docs.microsoft.com/windows/desktop/shell/taskbar">Managing Taskbar Buttons</a>. For information on removing a window, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function. The following predefined control classes can be specified in the <i>lpClassName</i> parameter. Note the corresponding control styles you can use in the <i>dwStyle</i> parameter. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DefWindowProc(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <summary>Calls the default window procedure to provide default processing for any window messages that an application does not process. (Unicode)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window procedure that received the message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Msg">
            <para>Type: <b>UINT</b> The message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wParam">
            <para>Type: <b>WPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>LRESULT</b> The return value is the result of the message processing and depends on the message.</para>
            </returns>
            <remarks>
            <para>> [!NOTE] > The winuser.h header defines DefWindowProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DispatchMessage(Windows.Win32.UI.WindowsAndMessaging.MSG@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.DispatchMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.DispatchMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*)">
            <summary>Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function. (DispatchMessageW)</summary>
            <param name="lpMsg">
            <para>Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b> A pointer to a structure that contains the message.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>LRESULT</b> The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.</para>
            </returns>
            <remarks>
            <para>The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure must contain valid message values. If the <i>lpmsg</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message and the <i>lParam</i> parameter of the <b>WM_TIMER</b> message is not <b>NULL</b>, <i>lParam</i> points to a function that is called instead of the window procedure. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">Dialog Box Keyboard Interface</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetMessage(Windows.Win32.UI.WindowsAndMessaging.MSG@,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*,Windows.Win32.Foundation.HWND,System.UInt32,System.UInt32)">
            <summary>Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval. (GetMessageW)</summary>
            <param name="lpMsg">
            <para>Type: <b>LPMSG</b> A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information from the thread's message queue.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
            <para>If <i>hWnd</i> is <b>NULL</b>, <b>GetMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed. If <i>hWnd</i> is -1, <b>GetMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>,  that is, thread messages as posted by  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wMsgFilterMin">
            <para>Type: <b>UINT</b> The integer value of the lowest message value to be retrieved. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message. Use <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMax</i> to specify only the <b>WM_INPUT</b> messages. If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wMsgFilterMax">
            <para>Type: <b>UINT</b> The integer value of the highest message value to be retrieved. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message.</para>
            <para>Use <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMin</i> to specify only the <b>WM_INPUT</b> messages. If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function retrieves a message other than <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a>, the return value is nonzero. If the function retrieves the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message, the return value is zero. If there is an error, the return value is -1. For example, the function fails if <i>hWnd</i> is an invalid window handle or <i>lpMsg</i> is an invalid pointer. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Because the return value can be nonzero, zero, or -1, avoid code like this:</para>
            <para></para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>An application typically uses the return value to determine whether to end the main message loop and exit the program. The <b>GetMessage</b> function retrieves messages associated with the window identified by the <i>hWnd</i> parameter or any of its children, as specified by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-ischild">IsChild</a> function, and within the range of message values given by the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. Note that an application can only use the low word in the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters; the high word is reserved for the system. Note that <b>GetMessage</b> always retrieves <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> messages, no matter which values you specify for <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i>. During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a> function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:</para>
            <para></para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.PostMessage(Windows.Win32.Foundation.HWND,System.UInt32,Windows.Win32.Foundation.WPARAM,Windows.Win32.Foundation.LPARAM)">
            <summary>Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message. (Unicode)</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window whose window procedure is to receive the message. The following values have special meanings. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Msg">
            <para>Type: <b>UINT</b> The message to be posted. For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="wParam">
            <para>Type: <b>WPARAM</b> Additional message-specific information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lParam">
            <para>Type: <b>LPARAM</b> Additional message-specific information.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied). Messages in a message queue are retrieved by calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function. Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication. The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling. If you send a message in the range below <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> to the asynchronous message functions (<b>PostMessage</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used. Do not post the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message using <b>PostMessage</b>; use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postquitmessage">PostQuitMessage</a> function. An accessibility application can use <b>PostMessage</b> to post <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-appcommand">WM_APPCOMMAND</a> messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications. There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large.  If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key. <pre><b>HKEY_LOCAL_MACHINE</b> <b>SOFTWARE</b> <b>Microsoft</b> <b>Windows NT</b> <b>CurrentVersion</b> <b>Windows</b> <b>USERPostMessageLimit</b></pre> If the function fails, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information. <b>GetLastError</b> returns <b>ERROR_NOT_ENOUGH_QUOTA</b> when the limit is hit. The minimum acceptable value is 4000.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyIcon(Windows.Win32.UI.WindowsAndMessaging.HICON)">
            <summary>Destroys an icon and frees any memory the icon occupied.</summary>
            <param name="hIcon">
            <para>Type: <b>HICON</b> A handle to the icon to be destroyed. The icon must not be in use.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>It is only necessary to call <b>DestroyIcon</b> for icons and cursors created with the following functions: <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> (if called without the <b>LR_SHARED</b> flag), <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyicon">CopyIcon</a>. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyCursor(Windows.Win32.UI.WindowsAndMessaging.HCURSOR)">
            <summary>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</summary>
            <param name="hCursor">
            <para>Type: <b>HCURSOR</b> A handle to the cursor to be destroyed. The cursor must not be in use.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The <b>DestroyCursor</b> function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor: </para>
            <para>This doc was truncated.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegisterClassEx(Windows.Win32.UI.WindowsAndMessaging.WNDCLASSEXW@)">
            <summary>Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function. (RegisterClassExW)</summary>
            <returns>
            <para>Type: <b>ATOM</b> If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>If you register the window class by using <b>RegisterClassExA</b>, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using <b>RegisterClassExW</b>, the application requests that the system pass text parameters of messages as Unicode. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-iswindowunicode">IsWindowUnicode</a> function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. All window classes that an application registers are unregistered when it terminates. No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassexw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.UnregisterDeviceNotification(Windows.Win32.UI.WindowsAndMessaging.HDEVNOTIFY)">
            <summary>Closes the specified device notification handle.</summary>
            <param name="Handle">
            <para>Device notification handle returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerdevicenotificationa">RegisterDeviceNotification</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unregisterdevicenotification#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unregisterdevicenotification">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegisterDeviceNotification(System.Runtime.InteropServices.SafeHandle,System.Void*,Windows.Win32.UI.WindowsAndMessaging.REGISTER_NOTIFICATION_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.RegisterDeviceNotification(Windows.Win32.Foundation.HANDLE,System.Void*,Windows.Win32.UI.WindowsAndMessaging.REGISTER_NOTIFICATION_FLAGS)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.RegisterDeviceNotification(Windows.Win32.Foundation.HANDLE,System.Void*,Windows.Win32.UI.WindowsAndMessaging.REGISTER_NOTIFICATION_FLAGS)">
            <summary>Registers the device or type of device for which a window will receive notifications. (Unicode)</summary>
            <param name="hRecipient">
            <para>A handle to the window or service that will receive device events for the devices specified in the <i>NotificationFilter</i> parameter. The same window handle can be used in multiple calls to <b>RegisterDeviceNotification</b>. Services can specify either a window handle or service status handle.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerdevicenotificationw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="NotificationFilter">
            <para>A pointer to a block of data that specifies the type of device for which notifications should be sent. This block always begins with the <a href="https://docs.microsoft.com/windows/desktop/api/dbt/ns-dbt-dev_broadcast_hdr">DEV_BROADCAST_HDR</a> structure. The data following this header is dependent on the value of the <b>dbch_devicetype</b> member, which can be <b>DBT_DEVTYP_DEVICEINTERFACE</b> or <b>DBT_DEVTYP_HANDLE</b>. For more information, see Remarks.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerdevicenotificationw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Flags"></param>
            <returns>
            <para>If the function succeeds, the return value is a device notification handle. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Applications send event notifications using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-broadcastsystemmessage">BroadcastSystemMessage</a> function. Any application with a top-level window can receive basic notifications by processing the <a href="https://docs.microsoft.com/windows/desktop/DevIO/wm-devicechange">WM_DEVICECHANGE</a> message. Applications can use the <b>RegisterDeviceNotification</b> function to register to receive device notifications. Services can use the <b>RegisterDeviceNotification</b> function to register to receive device notifications. If a service specifies a window handle in the <i>hRecipient</i> parameter, the notifications are sent to the window procedure. If <i>hRecipient</i> is a service status handle, <b>SERVICE_CONTROL_DEVICEEVENT</b> notifications are sent to the service control handler. For more information about the service control handler, see <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nc-winsvc-lphandler_function_ex">HandlerEx</a>. Be sure to handle Plug and Play device events as quickly as possible. Otherwise, the system may become unresponsive. If your event handler is to perform an operation that may block execution (such as I/O), it is best to start another thread to perform the operation asynchronously. Device notification handles returned by <b>RegisterDeviceNotification</b> must be closed by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterdevicenotification">UnregisterDeviceNotification</a> function when they are no longer needed. The <a href="https://docs.microsoft.com/windows/desktop/DevIO/dbt-devicearrival">DBT_DEVICEARRIVAL</a> and <a href="https://docs.microsoft.com/windows/desktop/DevIO/dbt-deviceremovecomplete">DBT_DEVICEREMOVECOMPLETE</a> events are automatically broadcast to all top-level windows for port devices. Therefore, it is not necessary to call <b>RegisterDeviceNotification</b> for ports, and the function fails if the <b>dbch_devicetype</b> member is <b>DBT_DEVTYP_PORT</b>. Volume notifications are also broadcast to top-level windows, so the function fails if <b>dbch_devicetype</b> is <b>DBT_DEVTYP_VOLUME</b>. OEM-defined devices are not used directly by the system, so the function fails if <b>dbch_devicetype</b> is <b>DBT_DEVTYP_OEM</b>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerdevicenotificationw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.TranslateMessage(Windows.Win32.UI.WindowsAndMessaging.MSG@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.TranslateMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.TranslateMessage(Windows.Win32.UI.WindowsAndMessaging.MSG*)">
            <summary>Translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the next time the thread calls the GetMessage or PeekMessage function.</summary>
            <param name="lpMsg">
            <para>Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b> A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains message information retrieved from the calling thread's message queue by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translatemessage#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero. If the message is <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a>, <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a>, <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a>, or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a>, the return value is nonzero, regardless of the translation. If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.</para>
            </returns>
            <remarks>
            <para>The <b>TranslateMessage</b> function does not modify the message pointed to by the <i>lpMsg</i> parameter.</para>
            <para><a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a> combinations produce a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-char">WM_CHAR</a> or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-deadchar">WM_DEADCHAR</a> message. <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a> combinations produce a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syschar">WM_SYSCHAR</a> or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-sysdeadchar">WM_SYSDEADCHAR</a> message. <b>TranslateMessage</b> produces <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-char">WM_CHAR</a> messages only for keys that are mapped to ASCII characters by the keyboard driver. If applications process virtual-key messages for some other purpose, they should not call <b>TranslateMessage</b>. For instance, an application should not call <b>TranslateMessage</b> if the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-translateacceleratora">TranslateAccelerator</a> function returns a nonzero value. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a>. For more information, see  <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">Dialog Box Keyboard Interface</a>.</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translatemessage#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Security.SECURITY_ATTRIBUTES">
            <summary>The SECURITY_ATTRIBUTES structure contains the security descriptor for an object and specifies whether the handle retrieved by specifying this structure is inheritable.</summary>
            <remarks></remarks>
        </member>
        <member name="F:Windows.Win32.Security.SECURITY_ATTRIBUTES.nLength">
            <summary>The size, in bytes, of this structure. Set this value to the size of the **SECURITY\_ATTRIBUTES** structure.</summary>
        </member>
        <member name="F:Windows.Win32.Security.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            <para>A pointer to a [**SECURITY\_DESCRIPTOR**](../winnt/ns-winnt-security_descriptor.md) structure that controls access to the object. If the value of this member is **NULL**, the object is assigned the default security descriptor associated with the [*access token*](/windows/win32/secauthz/access-tokens) of the calling process. This is not the same as granting access to everyone by assigning a **NULL** [*discretionary access control list*](/windows/win32/secauthz/dacls-and-aces) (DACL). By default, the default DACL in the access token of a process allows access only to the user represented by the access token. For information about creating a security descriptor, see [Creating a Security Descriptor](/windows/win32/secauthz/creating-a-security-descriptor-for-a-new-object-in-c--).</para>
            <para><see href="https://learn.microsoft.com/windows/win32/api/wtypesbase/ns-wtypesbase-security_attributes#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Security.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is **TRUE**, the new process inherits the handle.</summary>
        </member>
        <member name="T:Windows.Win32.UnregisterDeviceNotificationSafeHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:Windows.Win32.PInvoke.UnregisterDeviceNotification(Windows.Win32.UI.WindowsAndMessaging.HDEVNOTIFY)"/>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute">
            <summary>
            Specifies the priority of a member in overload resolution.
            When unspecified, the default priority is 0.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute"/> class.
            </summary>
            <param name="priority">The priority of the attributed member. Higher numbers are prioritized, lower numbers are deprioritized. 0 is the default if no attribute is present.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.Priority">
            <summary>
            The priority of the member.
            </summary>
        </member>
    </members>
</doc>
